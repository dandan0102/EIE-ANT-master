###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        01/Nov/2018  14:43:51
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpg_common\drivers\ant.c
#    Command line =  
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpg_common\drivers\ant.c" -D MPGL1 -D MPG1 -D
#        EIE1 --preprocess=cl
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\Debug\List\" -lC
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\Debug\List\" -o
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\EiE\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\" -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\bsp\" -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\drivers\" -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\application\" -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\" -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\"
#        -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\"
#        -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\"
#        -On --use_c++_inline --require_prototypes -I D:\EiE\arm\CMSIS\Include\
#    List file    =  
#        C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\Debug\List\ant.lst
#    Object file  =  
#        C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\Debug\Obj\ant.o
#
###############################################################################

C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding TestMessage\firmware_mpg_common\drivers\ant.c
      1          /***********************************************************************************************************************
                                                                                                                                        ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2          File: ant.c                                                               
      3          
      4          Description:
      5          ANT implementation for Atmel SAM3U2 Cortex-M3 / Ant slave SPI.  This driver requires synchronous
      6          SPI slave connection to an AP2 or AP2-emulated ANT device (the ANT device is the Master).  
      7          All interface layer code is maintained here.  
      8          Transmitted messages use the Message task; received messages use an SSP peripheral
      9          with SPI_SLAVE_FLOW_CONTROL.
     10          
     11          ------------------------------------------------------------------------------------------------------------------------
     12          
     13          
     14          ***********************************************************************************************************************/
     15          
     16          #include "configuration.h"
     17          
     18          /***********************************************************************************************************************
     19          * Bookmarks
     20          ************************************************************************************************************************
     21          !!!!! ANT Serial-layer Functions
     22          @@@@@ ANT Interface-layer Functions
     23          ##### ANT State Machine Definition                                             
     24          ***********************************************************************************************************************/
     25          
     26          /***********************************************************************************************************************
     27          Global variable definitions with scope across entire project.
     28          All Global variable names shall start with "G_<type>Ant"
     29          ***********************************************************************************************************************/
     30          
     31          /* New variables */

   \                                 In section .bss, align 4
     32          u32 G_u32AntFlags;                                    /* Flag bits for ANT-related information */
   \                     G_u32AntFlags:
   \   00000000                      DS8 4
     33          

   \                                 In section .bss, align 4
     34          AntAssignChannelInfoType G_asAntChannelConfiguration[ANT_NUM_CHANNELS]; /* Keeps track of all configured ANT channels */
   \                     G_asAntChannelConfiguration:
   \   00000000                      DS8 160

   \                                 In section .bss, align 4
     35          AntMessageResponseType G_stMessageResponse;           /* Holds the latest message response info */
   \                     G_stMessageResponse:
   \   00000000                      DS8 4
     36          

   \                                 In section .bss, align 4
     37          AntApplicationMsgListType *G_sAntApplicationMsgList;  /* Public linked list of messages from ANT to the application */
   \                     G_sAntApplicationMsgList:
   \   00000000                      DS8 4
     38          

   \                                 In section .data, align 4
     39          u8 G_au8AntMessageOk[]     = "OK\n\r";
   \                     G_au8AntMessageOk:
   \   00000000   0x4F 0x4B          DC8 "OK\012\015"
   \              0x0A 0x0D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     40          u8 G_au8AntMessageFail[  ] = "FAIL\n\r";
   \                     G_au8AntMessageFail:
   \   00000000   0x46 0x41          DC8 "FAIL\012\015"
   \              0x49 0x4C    
   \              0x0A 0x0D    
   \              0x00         
   \   00000007   0x00               DC8 0
     41          
     42          /* Replace 'd' at [12] with channel number */

   \                                 In section .data, align 4
     43          u8 G_au8AntMessageAssign[]    = "ANT channel d assign "; 
   \                     G_au8AntMessageAssign:
   \   00000000   0x41 0x4E          DC8 "ANT channel d assign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     44          u8 G_au8AntMessageUnassign[]  = "ANT channel d unassign ";
   \                     G_au8AntMessageUnassign:
   \   00000000   0x41 0x4E          DC8 "ANT channel d unassign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x75 0x6E    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    

   \                                 In section .data, align 4
     45          u8 G_au8AntMessageUnhandled[] = "ANT channel d message 0xxx response dd ";
   \                     G_au8AntMessageUnhandled:
   \   00000000   0x41 0x4E          DC8 "ANT channel d message 0xxx response dd "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x6D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x30 0x78    
   \              0x78 0x78    
   \              0x20 0x72    
   \              0x65 0x73    
   \              0x70 0x6F    
   \              0x6E 0x73    
   \              0x65 0x20    
   \              0x64 0x64    
   \              0x20 0x00    

   \                                 In section .data, align 4
     46          u8 G_au8AntMessageSetup[] = "ANT channel d setup ";
   \                     G_au8AntMessageSetup:
   \   00000000   0x41 0x4E          DC8 "ANT channel d setup "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x75    
   \              0x70 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     47          u8 G_au8AntMessageClose[] = "ANT channel d close ";
   \                     G_au8AntMessageClose:
   \   00000000   0x41 0x4E          DC8 "ANT channel d close "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x63 0x6C    
   \              0x6F 0x73    
   \              0x65 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     48          u8 G_au8AntMessageOpen[]  = "ANT channel d open ";
   \                     G_au8AntMessageOpen:
   \   00000000   0x41 0x4E          DC8 "ANT channel d open "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x6F 0x70    
   \              0x65 0x6E    
   \              0x20 0x00    
     49          

   \                                 In section .data, align 4
     50          u8 G_au8AntMessageInit[]  = "Initializing ANT... ";
   \                     G_au8AntMessageInit:
   \   00000000   0x49 0x6E          DC8 "Initializing ANT... "
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x69    
   \              0x6E 0x67    
   \              0x20 0x41    
   \              0x4E 0x54    
   \              0x2E 0x2E    
   \              0x2E 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     51          u8 G_au8AntMessageInitFail[] = "failed. Host IOs set to HiZ.\r\n";
   \                     G_au8AntMessageInitFail:
   \   00000000   0x66 0x61          DC8 "failed. Host IOs set to HiZ.\015\012"
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x2E 0x20    
   \              0x48 0x6F    
   \              0x73 0x74    
   \              0x20 0x49    
   \              0x4F 0x73    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x48 0x69    
   \              0x5A 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .data, align 4
     52          u8 G_au8AntMessageNoAnt[] = "\n\r### nRF51422 Programming Mode: no ANT functionality ####\n\r";
   \                     G_au8AntMessageNoAnt:
   \   00000000   0x0A 0x0D          DC8 0AH, 0DH, 23H, 23H, 23H, 20H, 6EH, 52H
   \              0x23 0x23    
   \              0x23 0x20    
   \              0x6E 0x52    
   \   00000008   0x46 0x35          DC8 46H, 35H, 31H, 34H, 32H, 32H, 20H, 50H
   \              0x31 0x34    
   \              0x32 0x32    
   \              0x20 0x50    
   \   00000010   0x72 0x6F          DC8 72H, 6FH, 67H, 72H, 61H, 6DH, 6DH, 69H
   \              0x67 0x72    
   \              0x61 0x6D    
   \              0x6D 0x69    
   \   00000018   0x6E 0x67          DC8 6EH, 67H, 20H, 4DH, 6FH, 64H, 65H, 3AH
   \              0x20 0x4D    
   \              0x6F 0x64    
   \              0x65 0x3A    
   \   00000020   0x20 0x6E          DC8 20H, 6EH, 6FH, 20H, 41H, 4EH, 54H, 20H
   \              0x6F 0x20    
   \              0x41 0x4E    
   \              0x54 0x20    
   \   00000028   0x66 0x75          DC8 66H, 75H, 6EH, 63H, 74H, 69H, 6FH, 6EH
   \              0x6E 0x63    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \   00000030   0x61 0x6C          DC8 61H, 6CH, 69H, 74H, 79H, 20H, 23H, 23H
   \              0x69 0x74    
   \              0x79 0x20    
   \              0x23 0x23    
   \   00000038   0x23 0x23          DC8 23H, 23H, 0AH, 0DH, 0
   \              0x0A 0x0D    
   \              0x00         
   \   0000003D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     53          
     54          
     55          /* ANT message structures */

   \                                 In section .data, align 4
     56          u8 G_au8AntSetNetworkKey[]    = {MESG_NETWORK_KEY_SIZE, MESG_NETWORK_KEY_ID, 0 /* Network number */, 
   \                     G_au8AntSetNetworkKey:
   \   00000000   0x09 0x46          DC8 9, 70, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     57                                           0 /* KEY0 */, 0 /* KEY1 */, 0 /* KEY2 */, 0 /* KEY3 */, 
     58                                           0 /* KEY4 */, 0 /* KEY5 */, 0 /* KEY6 */, 0 /* KEY7 */, CS};

   \                                 In section .data, align 4
     59          u8 G_au8AntAssignChannel[]    = {MESG_ASSIGN_CHANNEL_SIZE, MESG_ASSIGN_CHANNEL_ID, 0 /* AntChannel */, 
   \                     G_au8AntAssignChannel:
   \   00000000   0x03 0x42          DC8 3, 66, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     60                                           0 /* AntChannelType */, 0 /* AntNetwork */, CS};

   \                                 In section .data, align 4
     61          u8 G_au8AntSetChannelID[]     = {MESG_CHANNEL_ID_SIZE, MESG_CHANNEL_ID_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelID:
   \   00000000   0x05 0x51          DC8 5, 81, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     62                                           0 /* AntDeviceIdLo */, 0 /* AntDeviceIdHi */, 0 /* AntDeviceType */, 
     63                                           0 /* AntTransmissionType */, CS};

   \                                 In section .data, align 4
     64          u8 G_au8AntSetChannelPeriod[] = {MESG_CHANNEL_MESG_PERIOD_SIZE, MESG_CHANNEL_MESG_PERIOD_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelPeriod:
   \   00000000   0x03 0x43          DC8 3, 67, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     65                                           0 /* AntChannelPeriodLo */, 0 /* AntChannelPeriodHi */, CS};

   \                                 In section .data, align 4
     66          u8 G_au8AntSetChannelRFFreq[] = {MESG_CHANNEL_RADIO_FREQ_SIZE, MESG_CHANNEL_RADIO_FREQ_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelRFFreq:
   \   00000000   0x02 0x45          DC8 2, 69, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     67                                           0 /* AntFrequency */, CS};           

   \                                 In section .data, align 4
     68          u8 G_au8AntSetChannelPower[]  = {MESG_RADIO_TX_POWER_SIZE, MESG_RADIO_TX_POWER_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelPower:
   \   00000000   0x02 0x47          DC8 2, 71, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     69                                           0 /* AntTxPower */, CS};        

   \                                 In section .data, align 4
     70          u8 G_au8AntLibConfig[]        = {MESG_LIB_CONFIG_SIZE, MESG_LIB_CONFIG_ID, 0, LIB_CONFIG_CHANNEL_ID_FLAG | LIB_CONFIG_RSSI_FLAG, CS};        
   \                     G_au8AntLibConfig:
   \   00000000   0x02 0x6E          DC8 2, 110, 0, 192, 0, 0, 0, 0
   \              0x00 0xC0    
   \              0x00 0x00    
   \              0x00 0x00    
     71          

   \                                 In section .data, align 4
     72          u8 G_au8AntBroadcastDataMessage[] = {MESG_DATA_SIZE, MESG_BROADCAST_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
   \                     G_au8AntBroadcastDataMessage:
   \   00000000   0x09 0x4E          DC8 9, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
     73          u8 G_au8AntAckDataMessage[] = {MESG_DATA_SIZE, MESG_ACKNOWLEDGED_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
   \                     G_au8AntAckDataMessage:
   \   00000000   0x09 0x4F          DC8 9, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
     74          u8 G_au8ANTGetVersion[]     = {MESG_REQUEST_SIZE, MESG_REQUEST_ID, 0, MESG_VERSION_ID, 0};   
   \                     G_au8ANTGetVersion:
   \   00000000   0x02 0x4D          DC8 2, 77, 0, 62, 0, 0, 0, 0
   \              0x00 0x3E    
   \              0x00 0x00    
   \              0x00 0x00    
     75          
     76          
     77          /*----------------------------------------------------------------------------*/
     78          /* Existing variables (defined in other files -- should all contain the "extern" keyword) 
     79          and indicate what file the variable is defined in. */
     80          extern u32 G_u32SystemFlags;                            /* From main.c */
     81          extern u32 G_u32ApplicationFlags;                       /* From main.c */
     82          
     83          extern volatile u32 G_u32SystemTime1ms;                 /* From board-specific source file */
     84          extern volatile u32 G_u32SystemTime1s;                  /* From board-specific source file */
     85          
     86          extern volatile u32 ANT_SSP_FLAGS;                      /* From configuration.h */
     87          
     88          
     89          /***********************************************************************************************************************
     90          Global variable definitions with scope limited to this local application.
     91          Variable names shall start with "Ant_<type>Name" and be declared as static.
     92          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     93          static fnCode_type Ant_pfnStateMachine;                 /* The ANT state machine function pointer */
   \                     Ant_pfnStateMachine:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     94          static u32 Ant_u32RxTimer;                              /* Dedicated timer for receiving bytes */
   \                     Ant_u32RxTimer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     95          static u32 Ant_u32TxTimer;                              /* Dedicated timer for transmitting bytes */
   \                     Ant_u32TxTimer:
   \   00000000                      DS8 4
     96          

   \                                 In section .bss, align 4
     97          static u32 Ant_u32TxByteCounter = 0;                    /* Counter counts callbacks on sent bytes */
   \                     Ant_u32TxByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     98          static u32 Ant_u32RxByteCounter = 0;                    /* Counter counts callbacks on received bytes */
   \                     Ant_u32RxByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     99          static u32 Ant_u32RxTimeoutCounter = 0;                 /* Increments any time an ANT reception times out */
   \                     Ant_u32RxTimeoutCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    100          static u32 Ant_u32UnexpectedByteCounter = 0;            /* Increments any time a byte is received that was not expected value */
   \                     Ant_u32UnexpectedByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    101          static u32 Ant_u32CurrentTxMessageToken = 0;            /* Token for message currently being sent to ANT */
   \                     Ant_u32CurrentTxMessageToken:
   \   00000000                      DS8 4
    102          

   \                                 In section .bss, align 4
    103          static SspConfigurationType Ant_sSspConfig;             /* Configuration information for SSP peripheral */
   \                     Ant_sSspConfig:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
    104          static SspPeripheralType* Ant_Ssp;                      /* Pointer to Ant's SSP peripheral object */
   \                     Ant_Ssp:
   \   00000000                      DS8 4
    105          

   \                                 In section .bss, align 4
    106          static u8 Ant_u8AntVersion[MESG_VERSION_SIZE];          /* ANT device version string */
   \                     Ant_u8AntVersion:
   \   00000000                      DS8 12
    107          

   \                                 In section .bss, align 4
    108          static u8 Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE];       /* Space for verified received ANT messages */
   \                     Ant_au8AntRxBuffer:
   \   00000000                      DS8 256

   \                                 In section .bss, align 4
    109          static u8 *Ant_pu8AntRxBufferNextChar;                  /* Pointer to next char to be written in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    110          static u8 *Ant_pu8AntRxBufferCurrentChar;               /* Pointer to the current char in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferCurrentChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    111          static u8 *Ant_pu8AntRxBufferUnreadMsg;                 /* Pointer to unread chars in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferUnreadMsg:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    112          static u8 Ant_u8AntNewRxMessages;                       /* Counter for number of new messages in AntRxBuffer */
   \                     Ant_u8AntNewRxMessages:
   \   00000000                      DS8 1
    113          

   \                                 In section .bss, align 4
    114          static u32 Ant_u32ApplicationMessageCount = 0;          /* Counts messages queued on G_sAntApplicationMsgList */
   \                     Ant_u32ApplicationMessageCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    115          static AntOutgoingMessageListType *Ant_psDataOutgoingMsgList; /* Linked list of outgoing ANT-formatted messages */
   \                     Ant_psDataOutgoingMsgList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    116          static u32 Ant_u32OutgoingMessageCount = 0;             /* Counts messages queued on Ant_psDataOutgoingMsgList */
   \                     Ant_u32OutgoingMessageCount:
   \   00000000                      DS8 4
    117          

   \                                 In section .bss, align 1
    118          static u8 Ant_u8SlaveMissedMessageHigh = 0;             /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageHigh:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    119          static u8 Ant_u8SlaveMissedMessageMid = 0;              /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageMid:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    120          static u8 Ant_u8SlaveMissedMessageLow = 0;              /* Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageLow:
   \   00000000                      DS8 1
    121          
    122          
    123          /* Debug variables */

   \                                 In section .bss, align 4
    124          static u32 Ant_DebugRxMessageCounter = 0;
   \                     Ant_DebugRxMessageCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    125          static u32 Ant_DebugTotalRxMessages = 0;
   \                     Ant_DebugTotalRxMessages:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    126          static u32 Ant_DebugProcessRxMessages = 0;
   \                     Ant_DebugProcessRxMessages:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    127          static u32 Ant_DebugQueuedDataMessages = 0;
   \                     Ant_DebugQueuedDataMessages:
   \   00000000                      DS8 4
    128          
    129          
    130          /***********************************************************************************************************************
    131          !!!!! ANT Serial-layer Functions
    132          ***********************************************************************************************************************/
    133          
    134          /* ANT Private Serial-layer Functions */
    135          
    136          /*------------------------------------------------------------------------------
    137          Function: AntSyncSerialInitialize
    138          
    139          Description:
    140          Properly sets up the ANT SPI interface and tests Host <-> ANT communications.
    141          
    142          Requires:
    143            - ANT_SPI is configured
    144            - !CS (SEN) interrupt should be enabled
    145          // - GPIO interrupts are configured and enabled
    146          
    147          Promises:
    148            - Ant_pu8AntRxBufferNextChar is initialized to start of AntRxBuffer
    149            - Ant_pu8AntRxBufferUnreadMsg is initialized to start of AntRxBuffer
    150            - Ant_u8AntNewRxMessages = 0;
    151            - ANT SSP CS and RX interrupts are enabled
    152            - If ANT starts up correctly and responds to version request, then 
    153              G_u32SystemFlags _APPLICATION_FLAGS_ANT is set and Ant_u8AntVersion is populated
    154              with the returned version information from the ANT IC.  
    155          */

   \                                 In section .text, align 2, keep-with-next
    156          static void AntSyncSerialInitialize(void)
    157          {
   \                     AntSyncSerialInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    158            u32 u32EventTimer;
    159            bool bErrorStatus = FALSE;
   \   00000004   0x2400             MOVS     R4,#+0
    160            
    161            /* Initialize buffer pointers */  
    162            Ant_pu8AntRxBufferNextChar    = Ant_au8AntRxBuffer;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    163            Ant_pu8AntRxBufferCurrentChar = Ant_au8AntRxBuffer;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000018   0x6008             STR      R0,[R1, #+0]
    164            Ant_pu8AntRxBufferUnreadMsg   = Ant_au8AntRxBuffer;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000022   0x6008             STR      R0,[R1, #+0]
    165            Ant_u8AntNewRxMessages = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    166           
    167            /* Reset the 51422 and initialize SRDY and MRDY */
    168            u32EventTimer = G_u32SystemTime1ms;
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x9000             STR      R0,[SP, #+0]
    169            ANT_RESET_ASSERT();
   \   00000034   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable14_6  ;; 0x400e0e34
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    170            SYNC_MRDY_DEASSERT();
   \   0000003E   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x400e0e30
   \   00000046   0x6008             STR      R0,[R1, #+0]
    171            SYNC_SRDY_DEASSERT();
   \   00000048   0xF05F 0x7080      MOVS     R0,#+16777216
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x400e0e30
   \   00000050   0x6008             STR      R0,[R1, #+0]
    172            while( !IsTimeUp(&u32EventTimer, ANT_RESET_WAIT_MS) );
   \                     ??AntSyncSerialInitialize_0: (+1)
   \   00000052   0x2164             MOVS     R1,#+100
   \   00000054   0xA800             ADD      R0,SP,#+0
   \   00000056   0x.... 0x....      BL       IsTimeUp
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD0F9             BEQ.N    ??AntSyncSerialInitialize_0
    173            ANT_RESET_DEASSERT();
   \   0000005E   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x400e0e30
   \   00000066   0x6008             STR      R0,[R1, #+0]
    174            u32EventTimer = G_u32SystemTime1ms;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x9000             STR      R0,[SP, #+0]
    175            while( !IsTimeUp(&u32EventTimer, ANT_RESTART_DELAY_MS) );
   \                     ??AntSyncSerialInitialize_1: (+1)
   \   00000070   0xF44F 0x717A      MOV      R1,#+1000
   \   00000074   0xA800             ADD      R0,SP,#+0
   \   00000076   0x.... 0x....      BL       IsTimeUp
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD0F8             BEQ.N    ??AntSyncSerialInitialize_1
    176          
    177            
    178            /* ANT should want to send message 0x6F now to indicate it has reset */
    179            u32EventTimer = G_u32SystemTime1ms;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable14_5
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x9000             STR      R0,[SP, #+0]
    180            while( !IS_SEN_ASSERTED() && !bErrorStatus )
   \                     ??AntSyncSerialInitialize_2: (+1)
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x07C0             LSLS     R0,R0,#+31
   \   0000008E   0xD409             BMI.N    ??AntSyncSerialInitialize_3
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0x2C00             CMP      R4,#+0
   \   00000094   0xD106             BNE.N    ??AntSyncSerialInitialize_3
    181            {
    182              bErrorStatus = IsTimeUp(&u32EventTimer, ANT_MSG_TIMEOUT_MS);
   \   00000096   0xF44F 0x717A      MOV      R1,#+1000
   \   0000009A   0xA800             ADD      R0,SP,#+0
   \   0000009C   0x.... 0x....      BL       IsTimeUp
   \   000000A0   0x0004             MOVS     R4,R0
   \   000000A2   0xE7F0             B.N      ??AntSyncSerialInitialize_2
    183            }
    184          
    185            if (!bErrorStatus)
   \                     ??AntSyncSerialInitialize_3: (+1)
   \   000000A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A6   0x2C00             CMP      R4,#+0
   \   000000A8   0xD113             BNE.N    ??AntSyncSerialInitialize_4
    186            {
    187              /* Receive and process the restart message */
    188              AntRxMessage();
   \   000000AA   0x.... 0x....      BL       AntRxMessage
    189              AntProcessMessage();   
   \   000000AE   0x.... 0x....      BL       AntProcessMessage
    190          
    191            /* Send out version request message and expect response */
    192              G_au8ANTGetVersion[4] = AntCalculateTxChecksum(&G_au8ANTGetVersion[0]);
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable14_9
   \   000000B6   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable14_9
   \   000000BE   0x7108             STRB     R0,[R1, #+4]
    193              AntTxMessage(&G_au8ANTGetVersion[0]);    
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable14_9
   \   000000C4   0x.... 0x....      BL       AntTxMessage
    194              AntExpectResponse(MESG_VERSION_ID, ANT_MSG_TIMEOUT_MS);
   \   000000C8   0xF44F 0x717A      MOV      R1,#+1000
   \   000000CC   0x203E             MOVS     R0,#+62
   \   000000CE   0x.... 0x....      BL       AntExpectResponse
    195            }
    196           
    197          } /* end AntSyncSerialInitialize */
   \                     ??AntSyncSerialInitialize_4: (+1)
   \   000000D2   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    198          
    199          
    200          /*-----------------------------------------------------------------------------
    201          Function: AntSrdyPulse
    202          
    203          Description:
    204          Pulses Srdy with added delays on the front and middle. 
    205          
    206          Requires:
    207            - 
    208          
    209          Promises:
    210            - A delay controlled by ANT_SRDY_DELAY is passed
    211            - SRDY is asserted
    212            - A delay of ANT_SRDY_PERIOD is passed
    213            - SRDY is deasserted
    214          */

   \                                 In section .text, align 2, keep-with-next
    215          static void AntSrdyPulse(void)
    216          {
    217            for(u32 i = 0; i < ANT_SRDY_DELAY; i++);
   \                     AntSrdyPulse: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \                     ??AntSrdyPulse_0: (+1)
   \   00000002   0x28C8             CMP      R0,#+200
   \   00000004   0xD201             BCS.N    ??AntSrdyPulse_1
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0xE7FB             B.N      ??AntSrdyPulse_0
    218            SYNC_SRDY_ASSERT();
   \                     ??AntSrdyPulse_1: (+1)
   \   0000000A   0xF05F 0x7080      MOVS     R0,#+16777216
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable14_6  ;; 0x400e0e34
   \   00000012   0x6008             STR      R0,[R1, #+0]
    219            
    220            for(u32 i = 0; i < ANT_SRDY_PERIOD; i++);
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??AntSrdyPulse_2: (+1)
   \   00000016   0x2814             CMP      R0,#+20
   \   00000018   0xD201             BCS.N    ??AntSrdyPulse_3
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xE7FB             B.N      ??AntSrdyPulse_2
    221            SYNC_SRDY_DEASSERT();
   \                     ??AntSrdyPulse_3: (+1)
   \   0000001E   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x400e0e30
   \   00000026   0x6008             STR      R0,[R1, #+0]
    222          
    223          } /* end AntSrdyPulse() */
   \   00000028   0x4770             BX       LR               ;; return
    224          
    225          
    226          /*-----------------------------------------------------------------------------
    227          Function: AntRxMessage
    228          
    229          Description:
    230          Completely receive a message from ANT to the Host.  Incoming bytes are deposited directly into the receive
    231          buffer from the SSP ISR which should be extremely fast and complete in a maximum of 500us.  
    232          
    233          Requires:
    234            - _SSP_CS_ASSERTED is set indicating a message is ready to come in 
    235            - G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set if the system wanted to transmit
    236              but ANT wanted to send a message at the same time (so MESG_TX_SYNC has already 
    237              been received); _SSP_RX_COMPLETE must still be set from this.
    238            - Ant_pu8AntRxBufferCurrentChar points to the first byte of the message
    239          
    240          Promises:
    241            - If a good new message has been received, then Ant_u8AntNewMessages is incremented
    242              and the message is at Ant_pu8AntRxBufferUnreadMsg in Ant_au8AntRxBuffer
    243            - If a good message is not received, then Ant_u8AntNewMessages is unchanged.
    244            - In both cases, Ant_pu8AntRxBufferNextChar points at the next empty buffer location
    245          */

   \                                 In section .text, align 2, keep-with-next
    246          static void AntRxMessage(void)
    247          {
   \                     AntRxMessage: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    248            u8 u8Checksum;
    249            u8 u8Length;
    250            u32 u32CurrentRxByteCount;
    251            u8 au8RxTimeoutMsg[] = "AntRx: timeout\n\r";
   \   00000004   0xA806             ADD      R0,SP,#+24
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable14_10
   \   0000000A   0x2211             MOVS     R2,#+17
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    252            u8 au8RxFailMsg[] = "AntRx: message failed\n\r";
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable14_11
   \   00000016   0x2218             MOVS     R2,#+24
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy4
    253            bool bReceptionError = FALSE;
   \   0000001C   0x2700             MOVS     R7,#+0
    254            
    255            /* Ensure we have CS flag */
    256            if( !( IS_SEN_ASSERTED() ) )
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xF140 0x810B      BPL.W    ??AntRxMessage_0
    257            {
    258              return;
    259            }
    260            
    261            /* Initialize the receive timer and get a snapshot of current byte count */
    262            u32CurrentRxByteCount = Ant_u32RxByteCounter;
   \                     ??AntRxMessage_1: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14_12
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0006             MOVS     R6,R0
    263            Ant_u32RxTimer = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   00000038   0x6008             STR      R0,[R1, #+0]
    264            
    265            /* If the Global _ANT_FLAGS_TX_INTERRUPTED flag has been set, then we have already read the TX_SYNC byte */
    266            if(G_u32AntFlags & _ANT_FLAGS_TX_INTERRUPTED)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x00C0             LSLS     R0,R0,#+3
   \   00000042   0xD509             BPL.N    ??AntRxMessage_2
    267            {
    268              /* Clear flag and load the value we know was already received to allow the function to proceed*/
    269              G_u32AntFlags &= ~_ANT_FLAGS_TX_INTERRUPTED;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \   00000052   0x6008             STR      R0,[R1, #+0]
    270              
    271              /* Adjust the starting byte counter since it came in during AntTxMessage */
    272              u32CurrentRxByteCount--;
   \   00000054   0x1E76             SUBS     R6,R6,#+1
   \   00000056   0xE015             B.N      ??AntRxMessage_3
    273              
    274            }
    275            /* Otherwise we need to first read the sync byte  */
    276            else
    277            {
    278              /* Do short delay then cycle SRDY to get the first byte */
    279              AntSrdyPulse();
   \                     ??AntRxMessage_2: (+1)
   \   00000058   0x.... 0x....      BL       AntSrdyPulse
    280          
    281              /* Begin the receive cycle that takes place using interrupts and callbacks and is monitored by a timeout of 
    282              about 500us - this should be plenty of time to receive even the longest ANT message but still only half the 
    283              allowed 1ms loop time for the system. */
    284              
    285              /* Read the first byte when it comes in */
    286              while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) &&
    287                     (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_4: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x0740             LSLS     R0,R0,#+29
   \   00000064   0xD40E             BMI.N    ??AntRxMessage_3
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF242 0x7110      MOVW     R1,#+10000
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD207             BCS.N    ??AntRxMessage_3
    288              {
    289                Ant_u32RxTimer++;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   00000080   0x6008             STR      R0,[R1, #+0]
   \   00000082   0xE7EB             B.N      ??AntRxMessage_4
    290              }
    291            }
    292            
    293            if( Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT) 
   \                     ??AntRxMessage_3: (+1)
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0xF242 0x7111      MOVW     R1,#+10001
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD305             BCC.N    ??AntRxMessage_5
    294            {
    295              AntAbortMessage();
   \   00000092   0x.... 0x....      BL       AntAbortMessage
    296              DebugPrintf(au8RxTimeoutMsg);
   \   00000096   0xA806             ADD      R0,SP,#+24
   \   00000098   0x.... 0x....      BL       DebugPrintf
    297              return;
   \   0000009C   0xE0D0             B.N      ??AntRxMessage_0
    298            }
    299          
    300            /* _SSP_RX_COMPLETE flag will be set and the Rx callback will have run.  
    301            The callback does NOT toggle SRDY yet.  _SSP_RX_COMPLETE should still
    302            be set from AntTxMessage if that's what got us here. */
    303            ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE;
   \                     ??AntRxMessage_5: (+1)
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    304             
    305            /* One way or the other, we now have a potential SYNC byte at Ant_pu8AntRxBufferCurrentChar.  
    306            Proceed to test it and receive the rest of the message */
    307            if (*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC)                     
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x7800             LDRB     R0,[R0, #+0]
   \   000000B6   0x28A4             CMP      R0,#+164
   \   000000B8   0xF040 0x8086      BNE.W    ??AntRxMessage_6
    308            {
    309              /* Flag that a reception is in progress */
    310              G_u32AntFlags |= _ANT_FLAGS_RX_IN_PROGRESS;
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    311              
    312              /* Delay and then cycle SRDY to get the next byte (length) */
    313              AntSrdyPulse();
   \   000000CC   0x.... 0x....      BL       AntSrdyPulse
    314              
    315              /* The SSP interrupts and Rx callback handle the rest of the reception until a full message is received. 
    316              We know it is received when SEN is deasserted. */
    317              while( IS_SEN_ASSERTED() && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_7: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x07C0             LSLS     R0,R0,#+31
   \   000000D8   0xD50E             BPL.N    ??AntRxMessage_8
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0xF242 0x7110      MOVW     R1,#+10000
   \   000000E4   0x4288             CMP      R0,R1
   \   000000E6   0xD207             BCS.N    ??AntRxMessage_8
    318              {
    319                Ant_u32RxTimer++;
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x1C40             ADDS     R0,R0,#+1
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   000000F4   0x6008             STR      R0,[R1, #+0]
   \   000000F6   0xE7EB             B.N      ??AntRxMessage_7
    320              }
    321            
    322              /* One way or another, this Rx is done! */
    323              G_u32AntFlags &= ~_ANT_FLAGS_RX_IN_PROGRESS;
   \                     ??AntRxMessage_8: (+1)
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \   00000106   0x6008             STR      R0,[R1, #+0]
    324              ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   00000116   0x6008             STR      R0,[R1, #+0]
    325          
    326              /* Check that the above loop ended as expected and didn't time out */
    327              if(Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT)
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xD246             BCS.N    ??AntRxMessage_9
    328              {  
    329                /* Update counter to see how many bytes we should have */
    330                u32CurrentRxByteCount = Ant_u32RxByteCounter - u32CurrentRxByteCount;
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable14_12
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0x1B86             SUBS     R6,R0,R6
    331              
    332                /* RxBufferCurrentChar is still pointing to the SYNC byte. Validate what should be a complete message now. */
    333                u8Checksum = *Ant_pu8AntRxBufferCurrentChar;
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0x7800             LDRB     R0,[R0, #+0]
   \   00000136   0x0004             MOVS     R4,R0
    334                AdvanceAntRxBufferCurrentChar();
   \   00000138   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    335                
    336                /* Read the length byte and add two to count the length byte and message ID but not checksum as length will be our checksum counter */
    337                u8Length = *Ant_pu8AntRxBufferCurrentChar + 2;  
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x7800             LDRB     R0,[R0, #+0]
   \   00000144   0x1C80             ADDS     R0,R0,#+2
   \   00000146   0x0005             MOVS     R5,R0
    338                
    339                /* Optional check (u8Length does not include the SYNC byte or Checksum byte so add 2) */
    340                if(u32CurrentRxByteCount != (u8Length + 2) )
   \   00000148   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000014A   0x1CA8             ADDS     R0,R5,#+2
   \   0000014C   0x4286             CMP      R6,R0
   \   0000014E   0xD007             BEQ.N    ??AntRxMessage_10
    341                {
    342                  /* Could throw out the message right away - this could save some potential weird memory accesses
    343                  if there was any corruption or a wild u8Length value */
    344                  G_u32AntFlags |= _ANT_FLAGS_LENGTH_MISMATCH;
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   00000154   0x6800             LDR      R0,[R0, #+0]
   \   00000156   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \   0000015E   0x6008             STR      R0,[R1, #+0]
    345                }
    346           
    347                /* Validate the remaining bytes based on u8Length*/
    348                do
    349                {
    350                  u8Checksum ^= *Ant_pu8AntRxBufferCurrentChar;                     
   \                     ??AntRxMessage_10: (+1)
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000164   0x6800             LDR      R0,[R0, #+0]
   \   00000166   0x7800             LDRB     R0,[R0, #+0]
   \   00000168   0x4044             EORS     R4,R0,R4
    351                  AdvanceAntRxBufferCurrentChar();
   \   0000016A   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    352                } while (--u8Length);
   \   0000016E   0x1E6D             SUBS     R5,R5,#+1
   \   00000170   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000172   0x2D00             CMP      R5,#+0
   \   00000174   0xD1F4             BNE.N    ??AntRxMessage_10
    353                
    354                /* AntRxBufferCurrentChar is pointing to the last received byte that should be the checksum. */
    355                if (u8Checksum == *Ant_pu8AntRxBufferCurrentChar)      
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0x7800             LDRB     R0,[R0, #+0]
   \   0000017E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000180   0x4284             CMP      R4,R0
   \   00000182   0xD10E             BNE.N    ??AntRxMessage_11
    356                {
    357                  Ant_u8AntNewRxMessages++;
   \   00000184   0x.... 0x....      LDR.W    R0,??DataTable14_4
   \   00000188   0x7800             LDRB     R0,[R0, #+0]
   \   0000018A   0x1C40             ADDS     R0,R0,#+1
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000190   0x7008             STRB     R0,[R1, #+0]
    358                  Ant_DebugTotalRxMessages++;
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable14_15
   \   00000196   0x6800             LDR      R0,[R0, #+0]
   \   00000198   0x1C40             ADDS     R0,R0,#+1
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \   0000019E   0x6008             STR      R0,[R1, #+0]
   \   000001A0   0xE01B             B.N      ??AntRxMessage_12
    359                }
    360                /* If the message was not good, then move Ant_pu8AntRxBufferUnreadMsg passed the garbage data */
    361                else
    362                {
    363                  Ant_pu8AntRxBufferUnreadMsg = Ant_pu8AntRxBufferCurrentChar;
   \                     ??AntRxMessage_11: (+1)
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   000001AC   0x6008             STR      R0,[R1, #+0]
    364                  AdvanceAntRxBufferUnreadMsgPointer();
   \   000001AE   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   \   000001B2   0xE012             B.N      ??AntRxMessage_12
    365                }
    366              } 
    367              else
    368              {
    369                Ant_u32RxTimeoutCounter++;
   \                     ??AntRxMessage_9: (+1)
   \   000001B4   0x.... 0x....      LDR.W    R0,??DataTable14_16
   \   000001B8   0x6800             LDR      R0,[R0, #+0]
   \   000001BA   0x1C40             ADDS     R0,R0,#+1
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable14_16
   \   000001C0   0x6008             STR      R0,[R1, #+0]
    370                bReceptionError = TRUE;
   \   000001C2   0x2001             MOVS     R0,#+1
   \   000001C4   0x0007             MOVS     R7,R0
   \   000001C6   0xE008             B.N      ??AntRxMessage_12
    371              }
    372            } /* end if(*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC) */
    373            else
    374            {
    375              /* Otherwise we have received an unexpected byte -- flag it, clear Ssp flags and abandon the byte */
    376              Ant_u32UnexpectedByteCounter++;
   \                     ??AntRxMessage_6: (+1)
   \   000001C8   0x.... 0x....      LDR.W    R0,??DataTable14_17
   \   000001CC   0x6800             LDR      R0,[R0, #+0]
   \   000001CE   0x1C40             ADDS     R0,R0,#+1
   \   000001D0   0x.... 0x....      LDR.W    R1,??DataTable14_17
   \   000001D4   0x6008             STR      R0,[R1, #+0]
    377              bReceptionError = TRUE;
   \   000001D6   0x2001             MOVS     R0,#+1
   \   000001D8   0x0007             MOVS     R7,R0
    378            }
    379          
    380            /* If a reception error has occured, */
    381            if(bReceptionError)
   \                     ??AntRxMessage_12: (+1)
   \   000001DA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001DC   0x2F00             CMP      R7,#+0
   \   000001DE   0xD02D             BEQ.N    ??AntRxMessage_13
    382            {
    383              /* Toggle SRDY until CS deasserts and throw out the message */
    384              DebugPrintf(au8RxFailMsg);
   \   000001E0   0xA800             ADD      R0,SP,#+0
   \   000001E2   0x.... 0x....      BL       DebugPrintf
    385              while( IS_SEN_ASSERTED()  && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_14: (+1)
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   000001EA   0x6800             LDR      R0,[R0, #+0]
   \   000001EC   0x07C0             LSLS     R0,R0,#+31
   \   000001EE   0xD510             BPL.N    ??AntRxMessage_15
   \   000001F0   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   000001F4   0x6800             LDR      R0,[R0, #+0]
   \   000001F6   0xF242 0x7110      MOVW     R1,#+10000
   \   000001FA   0x4288             CMP      R0,R1
   \   000001FC   0xD209             BCS.N    ??AntRxMessage_15
    386              {
    387                Ant_u32RxTimer++;
   \   000001FE   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000202   0x6800             LDR      R0,[R0, #+0]
   \   00000204   0x1C40             ADDS     R0,R0,#+1
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   0000020A   0x6008             STR      R0,[R1, #+0]
    388                AntSrdyPulse();
   \   0000020C   0x.... 0x....      BL       AntSrdyPulse
   \   00000210   0xE7E9             B.N      ??AntRxMessage_14
    389              }
    390             
    391              /* Since we have flow control, we can safely assume that no other messages
    392              have come in and Ant_pu8AntRxBufferNextChar is pointing to where the next 
    393              valid message WILL come in - so push all the pointers there. */
    394              Ant_pu8AntRxBufferCurrentChar = Ant_pu8AntRxBufferNextChar;
   \                     ??AntRxMessage_15: (+1)
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000216   0x6800             LDR      R0,[R0, #+0]
   \   00000218   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   0000021C   0x6008             STR      R0,[R1, #+0]
    395              Ant_pu8AntRxBufferUnreadMsg = Ant_pu8AntRxBufferNextChar;
   \   0000021E   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000222   0x6800             LDR      R0,[R0, #+0]
   \   00000224   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000228   0x6008             STR      R0,[R1, #+0]
    396              ANT_SSP_FLAGS &= ~(_SSP_TX_COMPLETE | _SSP_RX_COMPLETE);
   \   0000022A   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   0000022E   0x6800             LDR      R0,[R0, #+0]
   \   00000230   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000234   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   00000238   0x6008             STR      R0,[R1, #+0]
   \   0000023A   0xE001             B.N      ??AntRxMessage_16
    397          
    398            }
    399            else
    400            {
    401              /* In all other cases, finish by advancing the current byte pointer */
    402              AdvanceAntRxBufferCurrentChar();
   \                     ??AntRxMessage_13: (+1)
   \   0000023C   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    403            }
    404            
    405          } /* end AntRxMessage() */
   \                     ??AntRxMessage_16: (+1)
   \                     ??AntRxMessage_0: (+1)
   \   00000240   0xB00B             ADD      SP,SP,#+44
   \   00000242   0xBDF0             POP      {R4-R7,PC}       ;; return
    406          
    407          
    408          /*-----------------------------------------------------------------------------
    409          Function: AntAbortMessage
    410          
    411          Description:
    412          Kills the current message in progress with ANT and resets all of the pointers.
    413          Any existing received buffer data is lost.
    414          
    415          *** Warning: all interrupts are disabled, so this could impact system tick time ***
    416          
    417          Requires:
    418            - 
    419          
    420          Promises:
    421            - Ant_pu8AntRxBufferNextChar, Ant_pu8AntRxBufferCurrentChar, Ant_pu8AntRxBufferUnreadMsg,
    422              and Ant_u8AntNewRxMessages reset.
    423          */

   \                                 In section .text, align 2, keep-with-next
    424          static void AntAbortMessage(void)
    425          {
    426            __disable_interrupt();
   \                     AntAbortMessage: (+1)
   \   00000000   0xB672             CPSID    I
    427            Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    428            Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000014   0x6008             STR      R0,[R1, #+0]
    429            Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    430            Ant_u8AntNewRxMessages = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    431            __enable_interrupt();
   \   00000028   0xB662             CPSIE    I
    432            
    433          } /* end AntAbortMessage() */
   \   0000002A   0x4770             BX       LR               ;; return
    434          
    435          
    436          /*-----------------------------------------------------------------------------
    437          Function: AdvanceAntRxBufferCurrentChar
    438          
    439          Description:
    440          Safely advances the Ant_pu8AntRxBufferCurrentChar within the circular buffer
    441          
    442          Requires:
    443            - No interrupt functions using Ant_pu8AntRxBufferCurrentChar are allowed to run
    444          
    445          Promises:
    446            - Ant_pu8AntRxBufferCurrentChar points to the next char to write in Ant_au8AntRxBuffer
    447          */

   \                                 In section .text, align 2, keep-with-next
    448          static void AdvanceAntRxBufferCurrentChar(void)
    449          {
    450            Ant_pu8AntRxBufferCurrentChar++;
   \                     AdvanceAntRxBufferCurrentChar: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    451            if(Ant_pu8AntRxBufferCurrentChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??AdvanceAntRxBufferCurrentChar_0
    452            {
    453              Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000024   0x6008             STR      R0,[R1, #+0]
    454            }
    455            
    456          } /* end AdvanceAntRxBufferCurrentChar() */
   \                     ??AdvanceAntRxBufferCurrentChar_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    457          
    458          
    459          /*-----------------------------------------------------------------------------/
    460          Function: AdvanceAntRxBufferUnreadMsgPointer
    461          
    462          Description:
    463          Increments the Rx buffer pointer and handles the wrap-around.
    464          
    465          Requires:
    466            - Ant_pu8AntRxBufferUnreadMsg cannot be moved in an ISR
    467          
    468          Promises:
    469            - Ant_pu8AntRxBufferUnreadMsg is pointing to the next char in the circular buffer
    470          */

   \                                 In section .text, align 2, keep-with-next
    471          static void AdvanceAntRxBufferUnreadMsgPointer()
    472          {
    473            Ant_pu8AntRxBufferUnreadMsg++;
   \                     AdvanceAntRxBufferUnreadMsgPointer: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    474            if (Ant_pu8AntRxBufferUnreadMsg == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??AdvanceAntRxBufferUnreadMsgPointer_0
    475            {
    476              Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000024   0x6008             STR      R0,[R1, #+0]
    477            }
    478            
    479          } /* end AdvanceAntRxBufferUnreadMsgPointer() */
   \                     ??AdvanceAntRxBufferUnreadMsgPointer_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    480          
    481            
    482          /*------------------------------------------------------------------------------
    483          Function: AntParseExtendedData
    484          
    485          Description:
    486          Reads extended data based on the flags that are set.
    487          Loads into AntExtendedDataType which currently has these fields:
    488          {
    489            u8 u8Channel;                        
    490            u16 u16DeviceID;                         
    491            u8 u8DeviceType;                         
    492            u8 u8TransType;                          
    493            u8 u8Flags;                             
    494            s8 s8RSSI;                              
    495          } AntExtendedDataType;
    496          
    497          Requires:
    498            - pu8SourceMessage_ points to an ANT message buffer that holds a complete ANT data
    499              message structure except for SYNC byte.  antmessage.h Buffer Indices an then be used.
    500            - psExtDataTarget_ points to the target AntExtendedDataType structure
    501          
    502          Promises:
    503            - If extended data is present, all values are read into local variables and then
    504              loaded into psExtDataTarget_ and the function returns TRUE.
    505            - If no extended data is present, psExtDataTarget_ is set to default values and
    506              the function returns FALSE.
    507          */

   \                                 In section .text, align 2, keep-with-next
    508          static bool AntParseExtendedData(u8* pu8SourceMessage, AntExtendedDataType* psExtDataTarget_)
    509          {
   \                     AntParseExtendedData: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    510            bool bReturnValue;
    511            u8 u8MessageSize;
    512            u8 u8Channel;                        
    513            u8 u8Flags = 0;       
   \   0000000A   0x2600             MOVS     R6,#+0
    514            u8 u8BufferOffset = 0;
   \   0000000C   0xF05F 0x0B00      MOVS     R11,#+0
    515            
    516            /* Channel ID extended data */
    517            u16 u16DeviceID = 0xFFFF;;                         
   \   00000010   0xF64F 0x7AFF      MOVW     R10,#+65535
    518            u8 u8DeviceType = 0xFF;                        
   \   00000014   0x20FF             MOVS     R0,#+255
   \   00000016   0xF88D 0x0002      STRB     R0,[SP, #+2]
    519            u8 u8TransType = 0xFF;                          
   \   0000001A   0x27FF             MOVS     R7,#+255
    520          
    521            /* RSSI extended data */
    522            s8 s8RSSI = 0xFF;           
   \   0000001C   0xF05F 0x38FF      MOVS     R8,#-1
    523            u8 u8MeasurementType = 0xFF;
                      ^
Warning[Pe550]: variable "u8MeasurementType" was set but never used
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0xF88D 0x0004      STRB     R0,[SP, #+4]
    524            u8 u8Threshold = 0xFF;
                      ^
Warning[Pe550]: variable "u8Threshold" was set but never used
   \   00000026   0x20FF             MOVS     R0,#+255
   \   00000028   0xF88D 0x0003      STRB     R0,[SP, #+3]
    525            
    526            /* RF Timestamp data */
    527            u16 u16RxTimestamp = 0xFFFF;
   \   0000002C   0xF64F 0x79FF      MOVW     R9,#+65535
    528              
    529            /* Get generic data */
    530            u8MessageSize = *(pu8SourceMessage + BUFFER_INDEX_MESG_SIZE);
   \   00000030   0x7820             LDRB     R0,[R4, #+0]
   \   00000032   0xF88D 0x0000      STRB     R0,[SP, #+0]
    531            u8Channel = *(pu8SourceMessage + BUFFER_INDEX_CHANNEL_NUM);
   \   00000036   0x78A0             LDRB     R0,[R4, #+2]
   \   00000038   0xF88D 0x0005      STRB     R0,[SP, #+5]
    532          
    533            /* Check to see if the message is the regular size (MESG_MAX_DATA_SIZE) */
    534            if(u8MessageSize == MESG_MAX_DATA_SIZE)
   \   0000003C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000040   0x2809             CMP      R0,#+9
   \   00000042   0xD103             BNE.N    ??AntParseExtendedData_0
    535            {
    536              bReturnValue = FALSE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000004A   0xE066             B.N      ??AntParseExtendedData_1
    537            }
    538            
    539            /* Check for a message that is too big or too small */
    540            else if( (u8MessageSize > MESG_MAX_SIZE) ||
    541                     (u8MessageSize < MESG_MAX_DATA_SIZE) )
   \                     ??AntParseExtendedData_0: (+1)
   \   0000004C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000050   0x2812             CMP      R0,#+18
   \   00000052   0xDA03             BGE.N    ??AntParseExtendedData_2
   \   00000054   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000058   0x2809             CMP      R0,#+9
   \   0000005A   0xDA07             BGE.N    ??AntParseExtendedData_3
    542            {
    543              DebugPrintf("\n\rUnexpected ANT message size\n\n\r");
   \                     ??AntParseExtendedData_2: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000060   0x.... 0x....      BL       DebugPrintf
    544              bReturnValue = FALSE;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000006A   0xE056             B.N      ??AntParseExtendedData_1
    545            }
    546            
    547            /* Otherwise we have some extended message data */
    548            else 
    549            {
    550              /* Byte after data must be flag byte */
    551              u8Flags = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA_FLAGS);
   \                     ??AntParseExtendedData_3: (+1)
   \   0000006C   0x7AE0             LDRB     R0,[R4, #+11]
   \   0000006E   0x0006             MOVS     R6,R0
    552              bReturnValue = TRUE;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xF88D 0x0001      STRB     R0,[SP, #+1]
    553              
    554              /* Channel ID information is always first if it's there */
    555              if(u8Flags & LIB_CONFIG_CHANNEL_ID_FLAG)
   \   00000076   0x0630             LSLS     R0,R6,#+24
   \   00000078   0xD521             BPL.N    ??AntParseExtendedData_4
    556              {
    557                u16DeviceID = (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) & 0x00FF;
   \   0000007A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000007E   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   00000082   0x7B00             LDRB     R0,[R0, #+12]
   \   00000084   0x4682             MOV      R10,R0
    558                u8BufferOffset++;
   \   00000086   0xF11B 0x0B01      ADDS     R11,R11,#+1
    559                u16DeviceID |= ( (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) << 8 ) & 0xFF00;
   \   0000008A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000008E   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   00000092   0x7B00             LDRB     R0,[R0, #+12]
   \   00000094   0xEA5A 0x2A00      ORRS     R10,R10,R0, LSL #+8
    560                u8BufferOffset++;
   \   00000098   0xF11B 0x0B01      ADDS     R11,R11,#+1
    561                u8DeviceType = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \   0000009C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000A0   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   000000A4   0x7B00             LDRB     R0,[R0, #+12]
   \   000000A6   0xF88D 0x0002      STRB     R0,[SP, #+2]
    562                u8BufferOffset++;
   \   000000AA   0xF11B 0x0B01      ADDS     R11,R11,#+1
    563                u8TransType = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \   000000AE   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000B2   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   000000B6   0x7B00             LDRB     R0,[R0, #+12]
   \   000000B8   0x0007             MOVS     R7,R0
    564                u8BufferOffset++;
   \   000000BA   0xF11B 0x0B01      ADDS     R11,R11,#+1
    565              }
    566              
    567              /* RSSI information is always next if it's there */
    568              if(u8Flags & LIB_CONFIG_RSSI_FLAG)
   \                     ??AntParseExtendedData_4: (+1)
   \   000000BE   0x0670             LSLS     R0,R6,#+25
   \   000000C0   0xD51A             BPL.N    ??AntParseExtendedData_5
    569              {
    570                u8MeasurementType = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \   000000C2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000C6   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   000000CA   0x7B00             LDRB     R0,[R0, #+12]
   \   000000CC   0xF88D 0x0004      STRB     R0,[SP, #+4]
    571                u8BufferOffset++;
   \   000000D0   0xF11B 0x0B01      ADDS     R11,R11,#+1
    572                s8RSSI = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \   000000D4   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000D8   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   000000DC   0xF990 0x000C      LDRSB    R0,[R0, #+12]
   \   000000E0   0x4680             MOV      R8,R0
    573                u8BufferOffset++;
   \   000000E2   0xF11B 0x0B01      ADDS     R11,R11,#+1
    574                u8Threshold = *(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \   000000E6   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000EA   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   000000EE   0x7B00             LDRB     R0,[R0, #+12]
   \   000000F0   0xF88D 0x0003      STRB     R0,[SP, #+3]
    575                u8BufferOffset++;
   \   000000F4   0xF11B 0x0B01      ADDS     R11,R11,#+1
    576             }   
    577          
    578              /* Timestamp information is always last */
    579              if(u8Flags & LIB_CONFIG_RX_TIMESTAMP_FLAG)
   \                     ??AntParseExtendedData_5: (+1)
   \   000000F8   0x06B0             LSLS     R0,R6,#+26
   \   000000FA   0xD50E             BPL.N    ??AntParseExtendedData_1
    580              {
    581                u16RxTimestamp = (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) & 0x00FF;
   \   000000FC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000100   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   00000104   0x7B00             LDRB     R0,[R0, #+12]
   \   00000106   0x4681             MOV      R9,R0
    582                u8BufferOffset++;
   \   00000108   0xF11B 0x0B01      ADDS     R11,R11,#+1
    583                u16RxTimestamp |= ( (u16)(*(pu8SourceMessage + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) << 8 ) & 0xFF00;
   \   0000010C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000110   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   00000114   0x7B00             LDRB     R0,[R0, #+12]
   \   00000116   0xEA59 0x2900      ORRS     R9,R9,R0, LSL #+8
    584              }
    585            }
    586            
    587            /* Load psExtDataTarget_ and return */
    588            psExtDataTarget_->u8Flags      = u8Flags;
   \                     ??AntParseExtendedData_1: (+1)
   \   0000011A   0x706E             STRB     R6,[R5, #+1]
    589            psExtDataTarget_->u8Channel    = u8Channel;
   \   0000011C   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000120   0x7028             STRB     R0,[R5, #+0]
    590            psExtDataTarget_->u16DeviceID  = u16DeviceID;
   \   00000122   0xF8A5 0xA002      STRH     R10,[R5, #+2]
    591            psExtDataTarget_->u8DeviceType = u8DeviceType;
   \   00000126   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000012A   0x7128             STRB     R0,[R5, #+4]
    592            psExtDataTarget_->u8TransType  = u8TransType;
   \   0000012C   0x716F             STRB     R7,[R5, #+5]
    593            psExtDataTarget_->s8RSSI       = s8RSSI;
   \   0000012E   0xF885 0x8006      STRB     R8,[R5, #+6]
    594          
    595            return bReturnValue;
   \   00000132   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000136   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    596            
    597          } /* end AntParseExtendedData */
    598          
    599          
    600          /***********************************************************************************************************************
    601          @@@@@ ANT Interface-layer Functions
    602          ***********************************************************************************************************************/
    603            
    604          /*------------------------------------------------------------------------------
    605          Function: AntInitialize
    606          
    607          Description:
    608          Intialize the ANT system.  ANT device is reset and communication checked through
    609          a version request.  The main channel parameters are then set up to default values.
    610            
    611          Requires:
    612            - ANT_SPI peripheral is correctly configured
    613            - Debug system is initialized so debug messages can be sent to UART
    614          
    615          Promises:
    616            - G_stAntSetupData set to default ANT values
    617            - If all successful, G_u32SystemFlags.AntGood bit is set and ANT system is ready
    618            - Ant_pfnStateMachine = AntSM_Idle
    619          */

   \                                 In section .text, align 2, keep-with-next
    620          void AntInitialize(void)
    621          {
   \                     AntInitialize: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    622            u32 u32AntPortAPins, u32AntPortBPins;
    623          
    624            if(G_u32SystemFlags & _SYSTEM_STARTUP_NO_ANT)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x01C0             LSLS     R0,R0,#+7
   \   0000000A   0xD509             BPL.N    ??AntInitialize_0
    625            {
    626              DebugPrintf(G_au8AntMessageNoAnt);
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000010   0x.... 0x....      BL       DebugPrintf
    627              Ant_pfnStateMachine = AntSM_NoResponse;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0xE103             B.N      ??AntInitialize_1
    628            }
    629            else
    630            {
    631              /* Give PIO control of ANT_RESET line */
    632              AT91C_BASE_PIOB->PIO_OER = PB_21_ANT_RESET;
   \                     ??AntInitialize_0: (+1)
   \   00000020   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable18_3  ;; 0x400e0e10
   \   00000028   0x6008             STR      R0,[R1, #+0]
    633              
    634              /* Announce on the debug port that ANT setup is starting and intialize pointers */
    635              DebugPrintf(G_au8AntMessageInit);
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \   0000002E   0x.... 0x....      BL       DebugPrintf
    636              G_sAntApplicationMsgList = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000038   0x6008             STR      R0,[R1, #+0]
    637              Ant_psDataOutgoingMsgList = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000040   0x6008             STR      R0,[R1, #+0]
    638            
    639            /* Initialize the G_asAntChannelConfiguration data struct */
    640            for(u8 i = 0; i < ANT_NUM_CHANNELS; i++)
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??AntInitialize_2: (+1)
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x2808             CMP      R0,#+8
   \   00000048   0xDA70             BGE.N    ??AntInitialize_3
    641            {
    642              G_asAntChannelConfiguration[i].AntChannel          = (AntChannelNumberType)i;
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2214             MOVS     R2,#+20
   \   00000052   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    643              G_asAntChannelConfiguration[i].AntChannelType      = 0xFF;
   \   00000058   0x21FF             MOVS     R1,#+255
   \   0000005A   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x2314             MOVS     R3,#+20
   \   00000062   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000066   0x7051             STRB     R1,[R2, #+1]
    644              G_asAntChannelConfiguration[i].AntNetwork          = 0xFF;
   \   00000068   0x21FF             MOVS     R1,#+255
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x2314             MOVS     R3,#+20
   \   00000072   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000076   0x7091             STRB     R1,[R2, #+2]
    645              G_asAntChannelConfiguration[i].AntDeviceIdLo       = 0xFF;
   \   00000078   0x21FF             MOVS     R1,#+255
   \   0000007A   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0x2314             MOVS     R3,#+20
   \   00000082   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000086   0x72D1             STRB     R1,[R2, #+11]
    646              G_asAntChannelConfiguration[i].AntDeviceIdHi       = 0xFF;
   \   00000088   0x21FF             MOVS     R1,#+255
   \   0000008A   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0x2314             MOVS     R3,#+20
   \   00000092   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000096   0x7311             STRB     R1,[R2, #+12]
    647              G_asAntChannelConfiguration[i].AntDeviceType       = 0xFF;
   \   00000098   0x21FF             MOVS     R1,#+255
   \   0000009A   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   0000009E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A0   0x2314             MOVS     R3,#+20
   \   000000A2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000A6   0x7351             STRB     R1,[R2, #+13]
    648              G_asAntChannelConfiguration[i].AntTransmissionType = 0xFF;
   \   000000A8   0x21FF             MOVS     R1,#+255
   \   000000AA   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B0   0x2314             MOVS     R3,#+20
   \   000000B2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000B6   0x7391             STRB     R1,[R2, #+14]
    649              G_asAntChannelConfiguration[i].AntChannelPeriodLo  = 0xFF;
   \   000000B8   0x21FF             MOVS     R1,#+255
   \   000000BA   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C0   0x2314             MOVS     R3,#+20
   \   000000C2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000C6   0x73D1             STRB     R1,[R2, #+15]
    650              G_asAntChannelConfiguration[i].AntChannelPeriodHi  = 0xFF;
   \   000000C8   0x21FF             MOVS     R1,#+255
   \   000000CA   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   000000CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D0   0x2314             MOVS     R3,#+20
   \   000000D2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000D6   0x7411             STRB     R1,[R2, #+16]
    651              G_asAntChannelConfiguration[i].AntFrequency        = 0xFF;
   \   000000D8   0x21FF             MOVS     R1,#+255
   \   000000DA   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0x2314             MOVS     R3,#+20
   \   000000E2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000E6   0x7451             STRB     R1,[R2, #+17]
    652              G_asAntChannelConfiguration[i].AntTxPower          = 0xFF;
   \   000000E8   0x21FF             MOVS     R1,#+255
   \   000000EA   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   000000EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F0   0x2314             MOVS     R3,#+20
   \   000000F2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000F6   0x7491             STRB     R1,[R2, #+18]
    653              G_asAntChannelConfiguration[i].AntFlags            = 0;
   \   000000F8   0x2100             MOVS     R1,#+0
   \   000000FA   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0x2314             MOVS     R3,#+20
   \   00000102   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000106   0x74D1             STRB     R1,[R2, #+19]
    654              
    655              for(u8 j = 0; j < ANT_NETWORK_NUMBER_BYTES; j++)
   \   00000108   0x2100             MOVS     R1,#+0
   \                     ??AntInitialize_4: (+1)
   \   0000010A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000010C   0x2908             CMP      R1,#+8
   \   0000010E   0xDA0B             BGE.N    ??AntInitialize_5
    656              {
    657                G_asAntChannelConfiguration[i].AntNetworkKey[j] = 0;
   \   00000110   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   00000114   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000116   0x2314             MOVS     R3,#+20
   \   00000118   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000011C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000011E   0x188A             ADDS     R2,R1,R2
   \   00000120   0x2300             MOVS     R3,#+0
   \   00000122   0x70D3             STRB     R3,[R2, #+3]
    658              }
   \   00000124   0x1C49             ADDS     R1,R1,#+1
   \   00000126   0xE7F0             B.N      ??AntInitialize_4
    659            }
   \                     ??AntInitialize_5: (+1)
   \   00000128   0x1C40             ADDS     R0,R0,#+1
   \   0000012A   0xE78B             B.N      ??AntInitialize_2
    660              
    661              /* Configure the SSP resource to be used for the application */
    662              Ant_sSspConfig.SspPeripheral      = ANT_SPI;
   \                     ??AntInitialize_3: (+1)
   \   0000012C   0x2004             MOVS     R0,#+4
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000132   0x7008             STRB     R0,[R1, #+0]
    663              Ant_sSspConfig.pCsGpioAddress     = ANT_SPI_CS_GPIO;
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x400e0e00
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000013C   0x6048             STR      R0,[R1, #+4]
    664              Ant_sSspConfig.u32CsPin           = ANT_SPI_CS_PIN;
   \   0000013E   0xF45F 0x0080      MOVS     R0,#+4194304
   \   00000142   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000146   0x6088             STR      R0,[R1, #+8]
    665              Ant_sSspConfig.BitOrder           = LSB_FIRST;
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000014E   0x7308             STRB     R0,[R1, #+12]
    666              Ant_sSspConfig.SpiMode            = SPI_SLAVE_FLOW_CONTROL;
   \   00000150   0x2002             MOVS     R0,#+2
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000156   0x7348             STRB     R0,[R1, #+13]
    667              Ant_sSspConfig.fnSlaveTxFlowCallback = AntTxFlowControlCallback;
   \   00000158   0x.... 0x....      ADR.W    R0,AntTxFlowControlCallback
   \   0000015C   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000160   0x6108             STR      R0,[R1, #+16]
    668              Ant_sSspConfig.fnSlaveRxFlowCallback = AntRxFlowControlCallback;
   \   00000162   0x.... 0x....      ADR.W    R0,AntRxFlowControlCallback
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000016A   0x6148             STR      R0,[R1, #+20]
    669              Ant_sSspConfig.pu8RxBufferAddress = Ant_au8AntRxBuffer;
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000170   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000174   0x6188             STR      R0,[R1, #+24]
    670              Ant_sSspConfig.ppu8RxNextByte     = &Ant_pu8AntRxBufferNextChar;
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000017E   0x61C8             STR      R0,[R1, #+28]
    671              Ant_sSspConfig.u16RxBufferSize    = ANT_RX_BUFFER_SIZE;
   \   00000180   0xF44F 0x7080      MOV      R0,#+256
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000188   0x8408             STRH     R0,[R1, #+32]
    672          
    673              Ant_Ssp = SspRequest(&Ant_sSspConfig);
   \   0000018A   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   0000018E   0x.... 0x....      BL       SspRequest
   \   00000192   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \   00000196   0x6008             STR      R0,[R1, #+0]
    674              ANT_SSP_FLAGS = 0;
   \   00000198   0x2000             MOVS     R0,#+0
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable14_8
   \   0000019E   0x6008             STR      R0,[R1, #+0]
    675              
    676              /* Reset ANT, activate SPI interface and get a test message */
    677              AntSyncSerialInitialize();
   \   000001A0   0x.... 0x....      BL       AntSyncSerialInitialize
    678              
    679              /* Report status out the debug port */
    680              if(G_u32ApplicationFlags & _APPLICATION_FLAGS_ANT)  
   \   000001A4   0x.... 0x....      LDR.W    R0,??DataTable21_3
   \   000001A8   0x7800             LDRB     R0,[R0, #+0]
   \   000001AA   0x06C0             LSLS     R0,R0,#+27
   \   000001AC   0xD51B             BPL.N    ??AntInitialize_6
    681              {
    682                DebugPrintf(G_au8AntMessageOk);
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \   000001B2   0x.... 0x....      BL       DebugPrintf
    683                DebugPrintf("ANT version: ");
   \   000001B6   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   000001BA   0x.... 0x....      BL       DebugPrintf
    684                DebugPrintf(Ant_u8AntVersion);
   \   000001BE   0x.... 0x....      LDR.W    R0,??DataTable21_5
   \   000001C2   0x.... 0x....      BL       DebugPrintf
    685                DebugLineFeed();
   \   000001C6   0x.... 0x....      BL       DebugLineFeed
    686                
    687                G_u32AntFlags &= ~_ANT_FLAGS_RESTART;
   \   000001CA   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   000001CE   0x6800             LDR      R0,[R0, #+0]
   \   000001D0   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000001D4   0x.... 0x....      LDR.W    R1,??DataTable14_14
   \   000001D8   0x6008             STR      R0,[R1, #+0]
    688                Ant_pfnStateMachine = AntSM_Idle;
   \   000001DA   0x.... 0x....      LDR.W    R0,??DataTable21_6
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000001E2   0x6008             STR      R0,[R1, #+0]
   \   000001E4   0xE020             B.N      ??AntInitialize_1
    689              }
    690              else
    691              {
    692                /* The ANT device is not responding -- it may be dead, or it may not yet
    693                be loaded with any firmware.  Regardless, float all of the interface lines so 
    694                that any programmer or other firmware will not be impacted by the Host MCU */
    695                DebugPrintf(G_au8AntMessageInitFail);
   \                     ??AntInitialize_6: (+1)
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable21_7
   \   000001EA   0x.... 0x....      BL       DebugPrintf
    696          
    697                /* Make sure all ANT pins are on the PIO controller */
    698                u32AntPortAPins = ANT_PIOA_PINS;
   \   000001EE   0xF05F 0x7030      MOVS     R0,#+46137344
   \   000001F2   0x0004             MOVS     R4,R0
    699                u32AntPortBPins = ANT_PIOB_PINS;
   \   000001F4   0xF05F 0x70F0      MOVS     R0,#+31457280
   \   000001F8   0x0005             MOVS     R5,R0
    700                
    701                AT91C_BASE_PIOA->PIO_PDR = u32AntPortAPins;
   \   000001FA   0x.... 0x....      LDR.W    R0,??DataTable21_8  ;; 0x400e0c04
   \   000001FE   0x6004             STR      R4,[R0, #+0]
    702                AT91C_BASE_PIOA->PIO_PER = u32AntPortAPins;
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable21_9  ;; 0x400e0c00
   \   00000204   0x6004             STR      R4,[R0, #+0]
    703                AT91C_BASE_PIOB->PIO_PDR = u32AntPortBPins;
   \   00000206   0x.... 0x....      LDR.W    R0,??DataTable21_10  ;; 0x400e0e04
   \   0000020A   0x6005             STR      R5,[R0, #+0]
    704                AT91C_BASE_PIOB->PIO_PER = u32AntPortBPins;
   \   0000020C   0x.... 0x....      LDR.W    R0,??DataTable20_4  ;; 0x400e0e00
   \   00000210   0x6005             STR      R5,[R0, #+0]
    705          
    706                /* Disable all outputs (set to HiZ input) */
    707                AT91C_BASE_PIOA->PIO_ODR = u32AntPortAPins;
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable21_11  ;; 0x400e0c14
   \   00000216   0x6004             STR      R4,[R0, #+0]
    708                AT91C_BASE_PIOB->PIO_ODR = u32AntPortBPins;
   \   00000218   0x.... 0x....      LDR.W    R0,??DataTable21_12  ;; 0x400e0e14
   \   0000021C   0x6005             STR      R5,[R0, #+0]
    709                
    710                Ant_pfnStateMachine = AntSM_NoResponse;
   \   0000021E   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000222   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000226   0x6008             STR      R0,[R1, #+0]
    711              }
    712            }
    713          } /* end AntInitialize() */
   \                     ??AntInitialize_1: (+1)
   \   00000228   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    714          
    715          
    716          /*----------------------------------------------------------------------------------------------------------------------
    717          Function AntRunActiveState()
    718          
    719          Description:
    720          Selects and runs one iteration of the current state in the state machine.
    721          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    722          may take 1ms / n to execute.
    723          
    724          Requires:
    725            - State machine function pointer points at current state
    726          
    727          Promises:
    728            - Calls the function to pointed by the state machine function pointer
    729          */

   \                                 In section .text, align 2, keep-with-next
    730          void AntRunActiveState(void)
    731          {
   \                     AntRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    732            Ant_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    733          
    734          } /* end AntRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    735          
    736          
    737          /*-----------------------------------------------------------------------------
    738          Function: AntTxMessage
    739          
    740          Description:
    741          Send a message from the Host to the ANT device.  To do this, we must tell ANT that we have
    742          a message to send by asserting MRDY, wait for ANT to acknowlege with SEN, then read a byte from
    743          ANT to confirm the transmission can proceed.  If ANT happens to wants to send a message at the
    744          same time, the byte it sends will be an Rx byte so the AntTxMessage must suspend and go read the 
    745          incoming message first.  The process would restart after that.
    746          
    747          Once ANT confirms that the Host may transmit, the message to transmit is queued and data is sent byte-by-byte with SRDY used for flow
    748          control after each byte.  Due to the speed of the chip-to-chip communications, even the longest ANT message
    749          should be able to send in less than 500us so it will likely be done on the main program cycle that
    750          immediately follows this call.  
    751          
    752          Requires:
    753            - pu8AntTxMessage_ points to an Ant formatted message where the first data byte
    754              is the length byte (since ANT sends the SYNC byte) and the last byte is
    755              the checksum.
    756          
    757          Promises:
    758            - Returns TRUE if the transmit message is queued successfully; Ant_u32CurrentTxMessageToken holds the message token
    759            - Returns FALSE if the transfer couldn't start or if receive message interrupted
    760              (G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set;  AntRxBufferCurrentChar pointing to the received byte).
    761            - MRDY is deasserted
    762          */

   \                                 In section .text, align 2, keep-with-next
    763          bool AntTxMessage(u8 *pu8AntTxMessage_)
    764          {
   \                     AntTxMessage: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB099             SUB      SP,SP,#+100
   \   00000004   0x0004             MOVS     R4,R0
    765            u8 u8Byte;
    766            u32 u32Length;
    767            u32 u32TimeOut = G_u32SystemTime1s;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable21_13
   \   0000000A   0x6807             LDR      R7,[R0, #+0]
    768            u8 au8TxInProgressMsg[] = "AntTx: msg already in progress\n\r";
   \   0000000C   0xA810             ADD      R0,SP,#+64
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable21_14
   \   00000012   0x2221             MOVS     R2,#+33
   \   00000014   0x.... 0x....      BL       __aeabi_memcpy
    769            u8 au8TxTimeoutMsg[]    = "AntTx: SEN timeout\n\r";
   \   00000018   0xA80A             ADD      R0,SP,#+40
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable21_15
   \   0000001E   0x2215             MOVS     R2,#+21
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy
    770            u8 au8TxNoTokenMsg[]    = "AntTx: No token\n\r";
   \   00000024   0xA805             ADD      R0,SP,#+20
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable21_16
   \   0000002A   0x2212             MOVS     R2,#+18
   \   0000002C   0x.... 0x....      BL       __aeabi_memcpy
    771            u8 au8TxNoSyncMsg[]     = "AntTx: No SYNC\n\r";
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable21_17
   \   00000036   0x2211             MOVS     R2,#+17
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
    772          
    773            /* Check G_u32AntFlags first */
    774            if(G_u32AntFlags & (_ANT_FLAGS_TX_IN_PROGRESS | _ANT_FLAGS_RX_IN_PROGRESS) )
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF010 0x6F40      TST      R0,#0xC000000
   \   00000046   0xD004             BEQ.N    ??AntTxMessage_0
    775            {
    776              DebugPrintf(au8TxInProgressMsg);
   \   00000048   0xA810             ADD      R0,SP,#+64
   \   0000004A   0x.... 0x....      BL       DebugPrintf
    777              return FALSE;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE08C             B.N      ??AntTxMessage_1
    778            }
    779            
    780            /* Initialize the timeout timer and notify ANT that the Host wishes to send a message */
    781            Ant_u32RxTimer = 0;
   \                     ??AntTxMessage_0: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   00000058   0x6008             STR      R0,[R1, #+0]
    782            SYNC_MRDY_ASSERT();                          
   \   0000005A   0xF45F 0x0000      MOVS     R0,#+8388608
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable14_6  ;; 0x400e0e34
   \   00000062   0x6008             STR      R0,[R1, #+0]
    783          
    784            /* Wait for SEN to be asserted indicating ANT is ready for a message */
    785            while ( !IS_SEN_ASSERTED() && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_2: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x07C0             LSLS     R0,R0,#+31
   \   0000006C   0xD40E             BMI.N    ??AntTxMessage_3
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0xF242 0x7110      MOVW     R1,#+10000
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD207             BCS.N    ??AntTxMessage_3
    786            {
    787              Ant_u32RxTimer++;
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable14_13
   \   00000088   0x6008             STR      R0,[R1, #+0]
   \   0000008A   0xE7EB             B.N      ??AntTxMessage_2
    788            }
    789            
    790            /* If we timed out, then clear MRDY and exit */
    791            if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \                     ??AntTxMessage_3: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0xF242 0x7111      MOVW     R1,#+10001
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD308             BCC.N    ??AntTxMessage_4
    792            {
    793              SYNC_MRDY_DEASSERT();                          
   \   0000009A   0xF45F 0x0000      MOVS     R0,#+8388608
   \   0000009E   0x....             LDR.N    R1,??DataTable14_7  ;; 0x400e0e30
   \   000000A0   0x6008             STR      R0,[R1, #+0]
    794              DebugPrintf(au8TxTimeoutMsg);
   \   000000A2   0xA80A             ADD      R0,SP,#+40
   \   000000A4   0x.... 0x....      BL       DebugPrintf
    795              return(FALSE);
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xE05F             B.N      ??AntTxMessage_1
    796            }
    797            
    798            /* Else we have SEN flag; queue to read 1 byte after a short delay before toggling SRDY */
    799            AntSrdyPulse();
   \                     ??AntTxMessage_4: (+1)
   \   000000AC   0x.... 0x....      BL       AntSrdyPulse
    800          
    801            /* Wait for the first byte to come in via the ISR / Rx Callback*/
    802            while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_5: (+1)
   \   000000B0   0x....             LDR.N    R0,??DataTable14_8
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x0740             LSLS     R0,R0,#+29
   \   000000B6   0xD40B             BMI.N    ??AntTxMessage_6
   \   000000B8   0x....             LDR.N    R0,??DataTable14_13
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF242 0x7110      MOVW     R1,#+10000
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xD205             BCS.N    ??AntTxMessage_6
    803            {
    804              Ant_u32RxTimer++;
   \   000000C4   0x....             LDR.N    R0,??DataTable14_13
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0x1C40             ADDS     R0,R0,#+1
   \   000000CA   0x....             LDR.N    R1,??DataTable14_13
   \   000000CC   0x6008             STR      R0,[R1, #+0]
   \   000000CE   0xE7EF             B.N      ??AntTxMessage_5
    805            }
    806          
    807            /* Ok to deassert MRDY now */
    808            SYNC_MRDY_DEASSERT();                     
   \                     ??AntTxMessage_6: (+1)
   \   000000D0   0xF45F 0x0000      MOVS     R0,#+8388608
   \   000000D4   0x....             LDR.N    R1,??DataTable14_7  ;; 0x400e0e30
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    809          
    810            /* If we timed out now, then clear MRDY and exit.  Because CS is still asserted, the task
    811            will attempt to read a message but fail and eventually abort. */
    812            if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \   000000D8   0x....             LDR.N    R0,??DataTable14_13
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0xF242 0x7111      MOVW     R1,#+10001
   \   000000E0   0x4288             CMP      R0,R1
   \   000000E2   0xD304             BCC.N    ??AntTxMessage_7
    813            {
    814             DebugPrintf(au8TxTimeoutMsg);
   \   000000E4   0xA80A             ADD      R0,SP,#+40
   \   000000E6   0x.... 0x....      BL       DebugPrintf
    815             return(FALSE);
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0xE03E             B.N      ??AntTxMessage_1
    816            }
    817                    
    818            /* When the byte comes in, the SSP module will set the _SSP_RX_COMPLETE flag and also call the 
    819            Rx callback but does not toggle SRDY at this time.  We must look at this byte to determine if ANT 
    820            initiated this particular communication and is telling us that a message is coming in, or if we 
    821            initiated the communication and ANT is allowing us to transmit. */
    822          
    823            /* Read the byte - don't advance the pointer yet */
    824            u8Byte = *Ant_pu8AntRxBufferCurrentChar;                       
   \                     ??AntTxMessage_7: (+1)
   \   000000EE   0x....             LDR.N    R0,??DataTable14_2
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0x7800             LDRB     R0,[R0, #+0]
   \   000000F4   0x0005             MOVS     R5,R0
    825          
    826            /* If the byte is TX_SYNC, then ANT wants to send a message which must be done first */
    827            if (u8Byte == MESG_TX_SYNC)                     
   \   000000F6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F8   0x2DA4             CMP      R5,#+164
   \   000000FA   0xD107             BNE.N    ??AntTxMessage_8
    828            {
    829              G_u32AntFlags |= _ANT_FLAGS_TX_INTERRUPTED;
   \   000000FC   0x....             LDR.N    R0,??DataTable14_14
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000104   0x....             LDR.N    R1,??DataTable14_14
   \   00000106   0x6008             STR      R0,[R1, #+0]
    830              return(FALSE);
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xE02F             B.N      ??AntTxMessage_1
    831            }
    832          
    833            /* Since the Rx byte is in our Rx buffer, advance both pointers since it's not an incoming message */
    834            AdvanceAntRxBufferCurrentChar();
   \                     ??AntTxMessage_8: (+1)
   \   0000010C   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    835            AdvanceAntRxBufferUnreadMsgPointer();
   \   00000110   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
    836          
    837            /* Clear the status flag and process the byte */
    838            ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE; /* !!!!! Odd for this to be here, but maybe it needs to be */
   \   00000114   0x....             LDR.N    R0,??DataTable14_8
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000011C   0x....             LDR.N    R1,??DataTable14_8
   \   0000011E   0x6008             STR      R0,[R1, #+0]
    839            
    840            /* If the byte is RX_SYNC, then proceed to send the message */
    841            if (u8Byte == MESG_RX_SYNC)                     
   \   00000120   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000122   0x2DA5             CMP      R5,#+165
   \   00000124   0xD11E             BNE.N    ??AntTxMessage_9
    842            {
    843              /* Flag that a transmit is in progress */
    844              G_u32AntFlags |= _ANT_FLAGS_TX_IN_PROGRESS;
   \   00000126   0x....             LDR.N    R0,??DataTable14_14
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   0000012E   0x....             LDR.N    R1,??DataTable14_14
   \   00000130   0x6008             STR      R0,[R1, #+0]
    845              
    846              /* Read the message length and add three for the length, message ID and checksum */
    847              u32Length = (u32)(pu8AntTxMessage_[0] + 3); 
   \   00000132   0x7820             LDRB     R0,[R4, #+0]
   \   00000134   0x1CC0             ADDS     R0,R0,#+3
   \   00000136   0x0006             MOVS     R6,R0
    848              
    849              /* Queue the message to the peripheral and capture the token */ 
    850              Ant_u32CurrentTxMessageToken = SspWriteData(Ant_Ssp, u32Length, pu8AntTxMessage_);
   \   00000138   0x0022             MOVS     R2,R4
   \   0000013A   0x0031             MOVS     R1,R6
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x.... 0x....      BL       SspWriteData
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   0000014A   0x6008             STR      R0,[R1, #+0]
    851          
    852              /* Return TRUE only if we received a message token indicating the message has been queued */
    853              if(Ant_u32CurrentTxMessageToken != 0)
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable21_18
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD001             BEQ.N    ??AntTxMessage_10
    854              {
    855                return(TRUE);
   \   00000156   0x2001             MOVS     R0,#+1
   \   00000158   0xE008             B.N      ??AntTxMessage_1
    856              }
    857              else
    858              {
    859                DebugPrintf(au8TxNoTokenMsg);
   \                     ??AntTxMessage_10: (+1)
   \   0000015A   0xA805             ADD      R0,SP,#+20
   \   0000015C   0x.... 0x....      BL       DebugPrintf
    860                return(FALSE);
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0xE003             B.N      ??AntTxMessage_1
    861              }
    862            }
    863          
    864            /* If we get here, not a sync byte, so return */
    865            DebugPrintf(au8TxNoSyncMsg);
   \                     ??AntTxMessage_9: (+1)
   \   00000164   0xA800             ADD      R0,SP,#+0
   \   00000166   0x.... 0x....      BL       DebugPrintf
    866            return(FALSE);
   \   0000016A   0x2000             MOVS     R0,#+0
   \                     ??AntTxMessage_1: (+1)
   \   0000016C   0xB019             ADD      SP,SP,#+100
   \   0000016E   0xBDF0             POP      {R4-R7,PC}       ;; return
    867          
    868          } /* end AntTxMessage() */
    869          
    870          
    871          /*------------------------------------------------------------------------------
    872          Function: AntExpectResponse
    873          
    874          Description:
    875          Waits a specified amount of time for a particular message to arrive from ANT in 
    876          response to a message sent to ANT.  
    877          
    878          *** This function violates the 1ms system rule, so should only be used during initialization. ***
    879            
    880          Requires:
    881            - u8ExpectedMessageID_ is the ID of a message to which a response is expected
    882            - u32TimeoutMS_ is the maximum value in ms to wait for the response 
    883            - A message had been sent to ANT to which a response should be coming in
    884            - Ant_u8AntNewRxMessages == 0 as this function is meant to run one-to-one with
    885              transmitted messages.
    886            - SSP task should be in manual mode so it is busy sending the Tx message to which
    887              this function will wait for the ANT response.
    888          
    889          Promises:
    890            - Returns 0 if the message is received and was successful
    891            - Returns 1 if a response is never received or if the response indicates the
    892              message was not successful.
    893          */

   \                                 In section .text, align 2, keep-with-next
    894          u8 AntExpectResponse(u8 u8ExpectedMessageID_, u32 u32TimeoutMS_) 
    895          {
   \                     AntExpectResponse: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    896            bool bTimeout = FALSE;
   \   00000008   0x2600             MOVS     R6,#+0
    897            u8 u8ReturnValue = 1;
   \   0000000A   0x2701             MOVS     R7,#+1
    898            u32 u32StartTime = G_u32SystemTime1s;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable21_13
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x9000             STR      R0,[SP, #+0]
    899            u8 au8AntExpectMsgFail[] = "\r\nANT expected msg fail\n\r";
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable21_19
   \   0000001A   0x221A             MOVS     R2,#+26
   \   0000001C   0x.... 0x....      BL       __aeabi_memcpy
    900          
    901            /* Wait for current message to send */
    902            u32StartTime = G_u32SystemTime1ms;
   \   00000020   0x....             LDR.N    R0,??DataTable14_5
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x9000             STR      R0,[SP, #+0]
    903            while( IS_SEN_ASSERTED() && !bTimeout )
   \                     ??AntExpectResponse_0: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable14_8
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x07C0             LSLS     R0,R0,#+31
   \   0000002C   0xD509             BPL.N    ??AntExpectResponse_1
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD106             BNE.N    ??AntExpectResponse_1
    904            {
    905              bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \   00000034   0xF44F 0x717A      MOV      R1,#+1000
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       IsTimeUp
   \   0000003E   0x0006             MOVS     R6,R0
   \   00000040   0xE7F1             B.N      ??AntExpectResponse_0
    906            }
    907          
    908            if( !bTimeout )
   \                     ??AntExpectResponse_1: (+1)
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD11C             BNE.N    ??AntExpectResponse_2
    909            {
    910              /* Done with this message token, so it can be cleared */
    911              G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \   00000048   0x....             LDR.N    R0,??DataTable14_14
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF030 0x6000      BICS     R0,R0,#0x8000000
   \   00000050   0x....             LDR.N    R1,??DataTable14_14
   \   00000052   0x6008             STR      R0,[R1, #+0]
    912              AntDeQueueOutgoingMessage();
   \   00000054   0x.... 0x....      BL       AntDeQueueOutgoingMessage
    913              Ant_u32CurrentTxMessageToken = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    914              
    915              /* Wait for SEN */
    916              u32StartTime = G_u32SystemTime1ms;
   \   00000060   0x....             LDR.N    R0,??DataTable14_5
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x9000             STR      R0,[SP, #+0]
    917              while( !IS_SEN_ASSERTED() && !bTimeout )
   \                     ??AntExpectResponse_3: (+1)
   \   00000066   0x....             LDR.N    R0,??DataTable14_8
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x07C0             LSLS     R0,R0,#+31
   \   0000006C   0xD409             BMI.N    ??AntExpectResponse_2
   \   0000006E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000070   0x2E00             CMP      R6,#+0
   \   00000072   0xD106             BNE.N    ??AntExpectResponse_2
    918              {
    919                bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \   00000074   0xF44F 0x717A      MOV      R1,#+1000
   \   00000078   0xA800             ADD      R0,SP,#+0
   \   0000007A   0x.... 0x....      BL       IsTimeUp
   \   0000007E   0x0006             MOVS     R6,R0
   \   00000080   0xE7F1             B.N      ??AntExpectResponse_3
    920              }
    921            }
    922            
    923            /* If no timeout then read the incoming message */
    924            if( !bTimeout )
   \                     ??AntExpectResponse_2: (+1)
   \   00000082   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000084   0x2E00             CMP      R6,#+0
   \   00000086   0xD11A             BNE.N    ??AntExpectResponse_4
    925            {
    926              AntRxMessage();
   \   00000088   0x.... 0x....      BL       AntRxMessage
    927          
    928              /* If there is a new message in the receive buffer, then check that it is a response to the expected
    929              message and that the response is no error */
    930              if(Ant_u8AntNewRxMessages)
   \   0000008C   0x....             LDR.N    R0,??DataTable14_4
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD014             BEQ.N    ??AntExpectResponse_4
    931              {
    932                /* Check if the response is an Event, the event is a reply to the expected message, and the reply is good.
    933                Since Ant_pu8AntRxBufferUnreadMsg is pointing to the SYNC byte, add 1 when using BUFFER_INDEX values. */
    934                if( (*(Ant_pu8AntRxBufferUnreadMsg + MESG_ID_OFFSET) == MESG_RESPONSE_EVENT_ID) &&    
    935                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_MESG_ID_OFFSET) == u8ExpectedMessageID_) &&
    936                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_CODE_OFFSET) == RESPONSE_NO_ERROR) )
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable21_20
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x7880             LDRB     R0,[R0, #+2]
   \   0000009C   0x2840             CMP      R0,#+64
   \   0000009E   0xD10E             BNE.N    ??AntExpectResponse_4
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable21_20
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0x7900             LDRB     R0,[R0, #+4]
   \   000000A8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AA   0x42A0             CMP      R0,R4
   \   000000AC   0xD107             BNE.N    ??AntExpectResponse_4
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable21_20
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x7940             LDRB     R0,[R0, #+5]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD101             BNE.N    ??AntExpectResponse_4
    937                {
    938                  u8ReturnValue = 0;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x0007             MOVS     R7,R0
    939                }
    940              }
    941            }
    942            
    943            /* Process any message in the RxBuffer and return the result value */
    944            AntProcessMessage();
   \                     ??AntExpectResponse_4: (+1)
   \   000000BE   0x.... 0x....      BL       AntProcessMessage
    945            
    946            if( bTimeout )
   \   000000C2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C4   0x2E00             CMP      R6,#+0
   \   000000C6   0xD002             BEQ.N    ??AntExpectResponse_5
    947            {
    948              DebugPrintf(au8AntExpectMsgFail);
   \   000000C8   0xA801             ADD      R0,SP,#+4
   \   000000CA   0x.... 0x....      BL       DebugPrintf
    949              /* !!!! What clean-up should be done here?  Reset ANT and restart init? */
    950            }
    951          
    952            return(u8ReturnValue);
   \                     ??AntExpectResponse_5: (+1)
   \   000000CE   0x0038             MOVS     R0,R7
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0xB009             ADD      SP,SP,#+36
   \   000000D4   0xBDF0             POP      {R4-R7,PC}       ;; return
    953          
    954          } /* end AntExpectResponse */
    955          
    956          
    957          /*-----------------------------------------------------------------------------
    958          Function: AntTxFlowControlCallback
    959          
    960          Description:
    961          Callback function to toggle flow control during transmission.  The peripheral task
    962          sending the message must invoke this function after each byte.  
    963          
    964          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    965          
    966          Requires:
    967            - 
    968          
    969          Promises:
    970            - SRDY is toggled
    971            - Ant_u32TxByteCounter incremented
    972          */
    973          

   \                                 In section .text, align 4, keep-with-next
    974          void AntTxFlowControlCallback(void)
    975          {
   \                     AntTxFlowControlCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    976            /* Count the byte and toggle flow control lines */
    977            Ant_u32TxByteCounter++; 
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable21_21
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable21_21
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    978            AntSrdyPulse();
   \   00000010   0x.... 0x....      BL       AntSrdyPulse
    979          
    980          } /* end AntTxFlowControlCallback() */
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    981          
    982          
    983          /*-----------------------------------------------------------------------------
    984          Function: AntRxFlowControlCallback
    985          
    986          Description:
    987          Callback function to toggle flow control during reception.  The peripheral task
    988          receiving the message must invoke this function after each byte.  
    989          
    990          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    991          Unfortunately, AntSrdyPulse() takes some time but the duty cycle of this interrupt
    992          is low enough that we can survive (this interrupt priority could be dropped below everything
    993          else to mitigate any issues).
    994          
    995          Requires:
    996            - ISRs are off already since this is totally not re-entrant
    997            - A received byte was just written to the Rx buffer
    998            - _SSP_CS_ASSERTED in correct state: should be set on first byte, but application should 
    999              clear it for all subsequent bytes so flow control is handled entirely by this function
   1000          
   1001          Promises:
   1002            - Ant_pu8AntRxBufferNextChar is advanced safely so it is ready to receive the next byte
   1003            - Ant_u32RxByteCounter incremented
   1004            - SRDY is toggled if _ANT_FLAGS_RX_IN_PROGRESS is set
   1005          */

   \                                 In section .text, align 4, keep-with-next
   1006          void AntRxFlowControlCallback(void)
   1007          {
   \                     AntRxFlowControlCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1008            /* Count the byte and safely advance the receive buffer pointer; this is called from the
   1009            RX ISR, so it won't be interrupted and break Ant_pu8AntRxBufferNextChar */
   1010            Ant_u32RxByteCounter++;
   \   00000002   0x....             LDR.N    R0,??DataTable14_12
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable14_12
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1011            Ant_pu8AntRxBufferNextChar++;
   \   0000000C   0x....             LDR.N    R0,??DataTable14_1
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x....             LDR.N    R1,??DataTable14_1
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1012            if(Ant_pu8AntRxBufferNextChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   00000016   0x....             LDR.N    R0,??DataTable14_1
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable15
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD103             BNE.N    ??AntRxFlowControlCallback_0
   1013            {
   1014              Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000026   0x....             LDR.N    R1,??DataTable14_1
   \   00000028   0x6008             STR      R0,[R1, #+0]
   1015            }
   1016            
   1017            /* Only toggle SRDY if a reception is flagged in progress */
   1018            if( G_u32AntFlags & _ANT_FLAGS_RX_IN_PROGRESS )
   \                     ??AntRxFlowControlCallback_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable21_22
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0140             LSLS     R0,R0,#+5
   \   00000032   0xD501             BPL.N    ??AntRxFlowControlCallback_1
   1019            {
   1020              AntSrdyPulse();
   \   00000034   0x.... 0x....      BL       AntSrdyPulse
   1021            }
   1022            
   1023          } /* end AntRxFlowControlCallback() */
   \                     ??AntRxFlowControlCallback_1: (+1)
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
   1024          
   1025          
   1026          /*------------------------------------------------------------------------------
   1027          Function: AntCalculateTxChecksum
   1028          
   1029          Description:
   1030          Calculates and returns the checksum for a Host > ANT message.
   1031          
   1032          Requires:
   1033            - pu8Message_ points to the message to transmit
   1034            - the message to transmit is a complete ANT message except the SYNC byte (starts with length byte)
   1035          
   1036          Promises:
   1037            - Finds ANT checksum for the message and returns it
   1038          */

   \                                 In section .text, align 2, keep-with-next
   1039          u8 AntCalculateTxChecksum(u8* pu8Message_)
   1040          {
   \                     AntCalculateTxChecksum: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
   1041            u8 u8Size = *pu8Message_ + 2;
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0x1C82             ADDS     R2,R0,#+2
   1042            u8 u8Checksum = MESG_RX_SYNC;
   \   00000008   0x20A5             MOVS     R0,#+165
   1043            
   1044            for(u8 i = 0; i < u8Size; i++)
   \   0000000A   0x2300             MOVS     R3,#+0
   \                     ??AntCalculateTxChecksum_0: (+1)
   \   0000000C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x4293             CMP      R3,R2
   \   00000012   0xD204             BCS.N    ??AntCalculateTxChecksum_1
   1045            {
   1046              u8Checksum ^= *pu8Message_;
   \   00000014   0x780C             LDRB     R4,[R1, #+0]
   \   00000016   0x4060             EORS     R0,R4,R0
   1047              pu8Message_++;
   \   00000018   0x1C49             ADDS     R1,R1,#+1
   1048            }
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
   \   0000001C   0xE7F6             B.N      ??AntCalculateTxChecksum_0
   1049            
   1050            return(u8Checksum);
   \                     ??AntCalculateTxChecksum_1: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
   1051            
   1052          } /* end AntCalculateTxChecksum() */
   1053          
   1054          
   1055          /*-----------------------------------------------------------------------------/
   1056          Function: AntQueueOutgoingMessage
   1057          
   1058          Description:
   1059          Creates a new ANT message structure and adds it into Ant_psDataOutgoingMsgList.
   1060          If the list is full, the message is not added.
   1061          The Outgoing message list are the messages sent from the Host to the ANT chip.
   1062          
   1063          Requires:
   1064            - pu8Message_ is an ANT-formatted message starting with LENGTH and ending with CHECKSUM
   1065            - Enough space is available on the heap
   1066          
   1067          Promises:
   1068            - A new list item in the outgoing message linked list is created and inserted at the end
   1069              of the list as long as there is enough room.
   1070            - Returns TRUE if the entry is added successfully.
   1071            - Returns FALSE on error.
   1072          */

   \                                 In section .text, align 2, keep-with-next
   1073          bool AntQueueOutgoingMessage(u8 *pu8Message_)
   1074          {
   \                     AntQueueOutgoingMessage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x0004             MOVS     R4,R0
   1075            u8 u8Length;
   1076            u8 u8MessageCount = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   1077            AntOutgoingMessageListType *psNewDataMessage;
   1078            AntOutgoingMessageListType *psListParser;
   1079            u8 au8AddMessageFailMsg[] = "\n\rNo space in AntQueueOutgoingMessage\n\r";
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable21_23
   \   00000010   0x2228             MOVS     R2,#+40
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy4
   1080            
   1081            /* Add to the number of queued message */
   1082            Ant_DebugQueuedDataMessages++;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable21_24
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable21_24
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1083          
   1084            /* Allocate space for the new message - always do maximum message size */
   1085            psNewDataMessage = malloc( sizeof(AntOutgoingMessageListType) );
   \   00000024   0x201C             MOVS     R0,#+28
   \   00000026   0x.... 0x....      BL       malloc
   \   0000002A   0x0007             MOVS     R7,R0
   1086            if (psNewDataMessage == NULL)
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD104             BNE.N    ??AntQueueOutgoingMessage_0
   1087            {
   1088              DebugPrintf(au8AddMessageFailMsg);
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      BL       DebugPrintf
   1089              return(FALSE);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE042             B.N      ??AntQueueOutgoingMessage_1
   1090            }
   1091            
   1092            /* Fill in all the fields of the newly allocated message structure */
   1093            u8Length = *pu8Message_ + 3;
   \                     ??AntQueueOutgoingMessage_0: (+1)
   \   0000003A   0x7820             LDRB     R0,[R4, #+0]
   \   0000003C   0x1CC0             ADDS     R0,R0,#+3
   \   0000003E   0x0005             MOVS     R5,R0
   1094            for(u8 i = 0; i < u8Length; i++)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??AntQueueOutgoingMessage_2: (+1)
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x42A8             CMP      R0,R5
   \   00000048   0xD206             BCS.N    ??AntQueueOutgoingMessage_3
   1095            {
   1096              psNewDataMessage->au8MessageData[i] = *(pu8Message_ + i);
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x5D01             LDRB     R1,[R0, R4]
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x19C2             ADDS     R2,R0,R7
   \   00000052   0x7111             STRB     R1,[R2, #+4]
   1097            }
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0xE7F4             B.N      ??AntQueueOutgoingMessage_2
   1098            
   1099            psNewDataMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueOutgoingMessage_3: (+1)
   \   00000058   0x....             LDR.N    R0,??DataTable14_5
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x6038             STR      R0,[R7, #+0]
   1100            psNewDataMessage->psNextMessage = NULL;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x61B8             STR      R0,[R7, #+24]
   1101          
   1102            /* Insert into an empty list */
   1103            if(Ant_psDataOutgoingMsgList == NULL)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD10A             BNE.N    ??AntQueueOutgoingMessage_4
   1104            {
   1105              Ant_psDataOutgoingMsgList = psNewDataMessage;
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000070   0x6007             STR      R7,[R0, #+0]
   1106              Ant_u32OutgoingMessageCount++;
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable21_25
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x1C40             ADDS     R0,R0,#+1
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable21_25
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   \   00000080   0xE01D             B.N      ??AntQueueOutgoingMessage_5
   1107            }
   1108          
   1109            /* Otherwise traverse the list to find the end where the new message will be inserted */
   1110            else
   1111            {
   1112              psListParser = Ant_psDataOutgoingMsgList;
   \                     ??AntQueueOutgoingMessage_4: (+1)
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x4680             MOV      R8,R0
   1113              while(psListParser->psNextMessage != NULL)  
   \                     ??AntQueueOutgoingMessage_6: (+1)
   \   0000008A   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD003             BEQ.N    ??AntQueueOutgoingMessage_7
   1114              {
   1115                psListParser = psListParser->psNextMessage;
   \   00000092   0xF8D8 0x8018      LDR      R8,[R8, #+24]
   1116                u8MessageCount++;
   \   00000096   0x1C76             ADDS     R6,R6,#+1
   \   00000098   0xE7F7             B.N      ??AntQueueOutgoingMessage_6
   1117              }
   1118              
   1119              /* Check for a full list */
   1120              if(u8MessageCount < ANT_OUTGOING_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueOutgoingMessage_7: (+1)
   \   0000009A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009C   0x2E20             CMP      R6,#+32
   \   0000009E   0xD209             BCS.N    ??AntQueueOutgoingMessage_8
   1121              {
   1122                /* Insert the new message at the end of the list */
   1123                psListParser->psNextMessage = psNewDataMessage;
   \   000000A0   0xF8C8 0x7018      STR      R7,[R8, #+24]
   1124                Ant_u32OutgoingMessageCount++;
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable21_25
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x1C40             ADDS     R0,R0,#+1
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable21_25
   \   000000B0   0x6008             STR      R0,[R1, #+0]
   \   000000B2   0xE004             B.N      ??AntQueueOutgoingMessage_5
   1125              }
   1126              else
   1127              {
   1128                DebugPrintf(au8AddMessageFailMsg);
   \                     ??AntQueueOutgoingMessage_8: (+1)
   \   000000B4   0xA800             ADD      R0,SP,#+0
   \   000000B6   0x.... 0x....      BL       DebugPrintf
   1129                return(FALSE);
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE000             B.N      ??AntQueueOutgoingMessage_1
   1130              }
   1131            }
   1132              
   1133            return(TRUE);
   \                     ??AntQueueOutgoingMessage_5: (+1)
   \   000000BE   0x2001             MOVS     R0,#+1
   \                     ??AntQueueOutgoingMessage_1: (+1)
   \   000000C0   0xB00A             ADD      SP,SP,#+40
   \   000000C2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1134            
   1135          } /* end AntQueueOutgoingMessage() */
   1136          
   1137          
   1138          /*-----------------------------------------------------------------------------/
   1139          Function: AntDeQueueApplicationMessage
   1140          
   1141          Description:
   1142          Releases the first message in G_sAntApplicationMsgList 
   1143          
   1144          Requires:
   1145            - G_sAntApplicationMsgList points to the start of the list which is the entry to remove
   1146          
   1147          Promises:
   1148            - G_sAntApplicationMsgList = G_sAntApplicationMsgList.
   1149          */

   \                                 In section .text, align 2, keep-with-next
   1150          void AntDeQueueApplicationMessage(void)
   1151          {
   \                     AntDeQueueApplicationMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1152            AntApplicationMsgListType *psMessageToKill;
   1153            
   1154            if(G_sAntApplicationMsgList != NULL)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD014             BEQ.N    ??AntDeQueueApplicationMessage_0
   1155            {
   1156              psMessageToKill = G_sAntApplicationMsgList;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x0004             MOVS     R4,R0
   1157              G_sAntApplicationMsgList = G_sAntApplicationMsgList->psNextMessage;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x6980             LDR      R0,[R0, #+24]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1158          
   1159              /* The doomed message is properly disconnected, so kill it */
   1160              free(psMessageToKill);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       free
   1161              Ant_u32ApplicationMessageCount--;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable21_26
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable21_26
   \   00000034   0x6008             STR      R0,[R1, #+0]
   1162            }
   1163            
   1164          } /* end AntDeQueueApplicationMessage() */
   \                     ??AntDeQueueApplicationMessage_0: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1165          
   1166          
   1167          /* ANT private Interface-layer Functions */
   1168          
   1169                                              
   1170          /*------------------------------------------------------------------------------
   1171          Function: AntProcessMessage
   1172          
   1173          Description:
   1174          Reads the lastest received Ant message and updates system information accordingly. 
   1175            
   1176          Requires:
   1177            - Ant_u8AntNewRxMessages holds the number of unprocessed messages in the message queue
   1178            - GGpu8AntRxBufferUnreadMsg points to the first byte of an unread verified ANT message
   1179          
   1180          Promises:
   1181            - Returns 1 if Ant_u8AntNewRxMessages == 0 or the message exceeds the maximum allowed length
   1182            - Otherwise, returns 0 and:
   1183              - Ant_u8AntNewRxMessages--
   1184              - GGpu8AntRxBufferUnreadMsg points to the first byte of the next unread verified ANT message
   1185              - System flags are updated
   1186          */

   \                                 In section .text, align 2, keep-with-next
   1187          static u8 AntProcessMessage(void)
   1188          {
   \                     AntProcessMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   1189            u8 u8MessageLength;
   1190            u8 u8Channel;
   1191            u8 au8MessageCopy[MESG_MAX_SIZE];
   1192            AntExtendedDataType sExtendedData;
   1193            
   1194             /* Exit immediately if there are no messages in the RxBuffer */
   1195          	if (!Ant_u8AntNewRxMessages)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable21_27
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??AntProcessMessage_0
   1196              return(1);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE1E1             B.N      ??AntProcessMessage_1
   1197            
   1198            Ant_DebugProcessRxMessages++;
   \                     ??AntProcessMessage_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable21_28
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable21_28
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1199            
   1200            /* Otherwise decrement counter, and get a copy of the message (necessary since the rx buffer is circular)
   1201            and we want to index the various bytes using the ANT byte definitions. */  
   1202            Ant_u8AntNewRxMessages--;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable21_27
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable21_27
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   1203            AdvanceAntRxBufferUnreadMsgPointer();
   \   0000002E   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1204            u8MessageLength = *Ant_pu8AntRxBufferUnreadMsg;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable21_20
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x0004             MOVS     R4,R0
   1205            
   1206            /* Check to ensure the message size is legit.  !!!!! Clean up pointers if not */
   1207            if(u8MessageLength > MESG_MAX_SIZE)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C12             CMP      R4,#+18
   \   00000040   0xDB01             BLT.N    ??AntProcessMessage_2
   1208            {
   1209              return(1);
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE1C7             B.N      ??AntProcessMessage_1
   1210            }
   1211            
   1212            /* Copy the message so it can be indexed easily */ 
   1213            for(u8 i = 0; i < (u8MessageLength + MESG_FRAME_SIZE - MESG_SYNC_SIZE); i++)
   \                     ??AntProcessMessage_2: (+1)
   \   00000046   0x2600             MOVS     R6,#+0
   \                     ??AntProcessMessage_3: (+1)
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0x1CE0             ADDS     R0,R4,#+3
   \   0000004E   0x4286             CMP      R6,R0
   \   00000050   0xDA0A             BGE.N    ??AntProcessMessage_4
   1214            {
   1215              au8MessageCopy[i] = *Ant_pu8AntRxBufferUnreadMsg;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable21_20
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0xA900             ADD      R1,SP,#+0
   \   0000005C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005E   0x5470             STRB     R0,[R6, R1]
   1216              AdvanceAntRxBufferUnreadMsgPointer();
   \   00000060   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1217            }
   \   00000064   0x1C76             ADDS     R6,R6,#+1
   \   00000066   0xE7EF             B.N      ??AntProcessMessage_3
   1218            /* Note: Ant_pu8AntRxBufferUnreadMsg is now pointing at the next unread message */
   1219            
   1220            /* Get the channel number since it is needed for many things below (this value
   1221            will NOT be the channel for messages that do not include the channel number,
   1222            but that should be fine as long as the value is used in the correct context. */
   1223            u8Channel = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM];
   \                     ??AntProcessMessage_4: (+1)
   \   00000068   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000006C   0x0005             MOVS     R5,R0
   1224            
   1225            /* Decide what to do based on the Message ID */
   1226            switch( au8MessageCopy[BUFFER_INDEX_MESG_ID] )
   \   0000006E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000072   0x283E             CMP      R0,#+62
   \   00000074   0xF000 0x818D      BEQ.W    ??AntProcessMessage_5
   \   00000078   0x2840             CMP      R0,#+64
   \   0000007A   0xD00C             BEQ.N    ??AntProcessMessage_6
   \   0000007C   0x284E             CMP      R0,#+78
   \   0000007E   0xF000 0x8171      BEQ.W    ??AntProcessMessage_7
   \   00000082   0x284F             CMP      R0,#+79
   \   00000084   0xF000 0x816E      BEQ.W    ??AntProcessMessage_7
   \   00000088   0x2852             CMP      R0,#+82
   \   0000008A   0xF000 0x8181      BEQ.W    ??AntProcessMessage_8
   \   0000008E   0x286F             CMP      R0,#+111
   \   00000090   0xF000 0x8193      BEQ.W    ??AntProcessMessage_9
   \   00000094   0xE198             B.N      ??AntProcessMessage_10
   1227            {
   1228              case MESG_RESPONSE_EVENT_ID:
   1229              { 
   1230                /* Channel Message received: it is a Channel Response or Channel Event */
   1231                if( au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] != MESG_EVENT_ID )
   \                     ??AntProcessMessage_6: (+1)
   \   00000096   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000009A   0x2801             CMP      R0,#+1
   \   0000009C   0xF000 0x80DA      BEQ.W    ??AntProcessMessage_11
   1232                {
   1233                  /* We have a Channel Response: parse it out based on the message ID to which the 
   1234                  response applies and post the result */
   1235                  G_stMessageResponse.u8Channel = u8Channel;
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable21_29
   \   000000A4   0x7005             STRB     R5,[R0, #+0]
   1236                  G_stMessageResponse.u8MessageNumber = au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID];
   \   000000A6   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable21_29
   \   000000AE   0x7048             STRB     R0,[R1, #+1]
   1237                  G_stMessageResponse.u8ResponseCode  = au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE];      
   \   000000B0   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable21_29
   \   000000B8   0x7088             STRB     R0,[R1, #+2]
   1238                  
   1239                  switch(au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID])
   \   000000BA   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000000BE   0x2841             CMP      R0,#+65
   \   000000C0   0xD063             BEQ.N    ??AntProcessMessage_12
   \   000000C2   0x2842             CMP      R0,#+66
   \   000000C4   0xD056             BEQ.N    ??AntProcessMessage_13
   \   000000C6   0x284B             CMP      R0,#+75
   \   000000C8   0xD007             BEQ.N    ??AntProcessMessage_14
   \   000000CA   0x284C             CMP      R0,#+76
   \   000000CC   0xD033             BEQ.N    ??AntProcessMessage_15
   \   000000CE   0x285B             CMP      R0,#+91
   \   000000D0   0xD17A             BNE.N    ??AntProcessMessage_16
   1240                  {
   1241                    case MESG_OPEN_SCAN_CHANNEL_ID:
   1242                      DebugPrintf("Scanning ");
   \                     ??AntProcessMessage_17: (+1)
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable21_30
   \   000000D6   0x.... 0x....      BL       DebugPrintf
   1243                      /* Fall through */
   1244                      
   1245                    case MESG_OPEN_CHANNEL_ID:
   1246                      G_au8AntMessageOpen[12] = u8Channel + 0x30;
   \                     ??AntProcessMessage_14: (+1)
   \   000000DA   0xF115 0x0030      ADDS     R0,R5,#+48
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable21_31
   \   000000E2   0x7308             STRB     R0,[R1, #+12]
   1247                      DebugPrintf(G_au8AntMessageOpen);
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable21_31
   \   000000E8   0x.... 0x....      BL       DebugPrintf
   1248                      
   1249                      /* Only change the flags if the command was successful */
   1250                      if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR )
   \   000000EC   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD11F             BNE.N    ??AntProcessMessage_18
   1251                      {
   1252                        G_asAntChannelConfiguration[u8Channel].AntFlags |= _ANT_FLAGS_CHANNEL_OPEN;
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   000000F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FA   0x2114             MOVS     R1,#+20
   \   000000FC   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000100   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000102   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   0000010A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010C   0x2214             MOVS     R2,#+20
   \   0000010E   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000112   0x74C8             STRB     R0,[R1, #+19]
   1253                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~_ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000118   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011A   0x2114             MOVS     R1,#+20
   \   0000011C   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000120   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000122   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   0000012A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000012C   0x2214             MOVS     R2,#+20
   \   0000012E   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000132   0x74C8             STRB     R0,[R1, #+19]
   1254                      }
   1255                      break;
   \                     ??AntProcessMessage_18: (+1)
   \   00000134   0xE078             B.N      ??AntProcessMessage_19
   1256          
   1257                    case MESG_CLOSE_CHANNEL_ID:
   1258                      G_au8AntMessageClose[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_15: (+1)
   \   00000136   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000013A   0x3030             ADDS     R0,R0,#+48
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable21_32
   \   00000140   0x7308             STRB     R0,[R1, #+12]
   1259                      DebugPrintf(G_au8AntMessageClose);
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable21_32
   \   00000146   0x.... 0x....      BL       DebugPrintf
   1260          
   1261                      /* Only change the flags if the command was successful */
   1262                      if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR )
   \   0000014A   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000014E   0x2800             CMP      R0,#+0
   \   00000150   0xD10F             BNE.N    ??AntProcessMessage_20
   1263                      {
   1264                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~(_ANT_FLAGS_CHANNEL_CLOSE_PENDING | _ANT_FLAGS_CHANNEL_OPEN);
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000156   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000158   0x2114             MOVS     R1,#+20
   \   0000015A   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000015E   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000160   0xF010 0x00F3      ANDS     R0,R0,#0xF3
   \   00000164   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000168   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000016A   0x2214             MOVS     R2,#+20
   \   0000016C   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000170   0x74C8             STRB     R0,[R1, #+19]
   1265                      }
   1266                      break;
   \                     ??AntProcessMessage_20: (+1)
   \   00000172   0xE059             B.N      ??AntProcessMessage_19
   1267          
   1268                    case MESG_ASSIGN_CHANNEL_ID:
   1269                      G_au8AntMessageAssign[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_13: (+1)
   \   00000174   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000178   0x3030             ADDS     R0,R0,#+48
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable21_33
   \   0000017E   0x7308             STRB     R0,[R1, #+12]
   1270                      DebugPrintf(G_au8AntMessageAssign);
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable21_33
   \   00000184   0x.... 0x....      BL       DebugPrintf
   1271                      break;
   \   00000188   0xE04E             B.N      ??AntProcessMessage_19
   1272          
   1273                    case MESG_UNASSIGN_CHANNEL_ID:
   1274                      G_au8AntMessageUnassign[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_12: (+1)
   \   0000018A   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000018E   0x3030             ADDS     R0,R0,#+48
   \   00000190   0x.... 0x....      LDR.W    R1,??DataTable21_34
   \   00000194   0x7308             STRB     R0,[R1, #+12]
   1275                      DebugPrintf(G_au8AntMessageUnassign);
   \   00000196   0x.... 0x....      LDR.W    R0,??DataTable21_34
   \   0000019A   0x.... 0x....      BL       DebugPrintf
   1276          
   1277                      /* Only change the flags if the command was successful */
   1278                      if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR )
   \   0000019E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000001A2   0x2800             CMP      R0,#+0
   \   000001A4   0xD10F             BNE.N    ??AntProcessMessage_21
   1279                      {
   1280                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~(_ANT_FLAGS_CHANNEL_OPEN_PENDING | _ANT_FLAGS_CHANNEL_CLOSE_PENDING | _ANT_FLAGS_CHANNEL_OPEN); /* !!!! 2016-06-14 */
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   000001AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001AC   0x2114             MOVS     R1,#+20
   \   000001AE   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000001B2   0x7CC0             LDRB     R0,[R0, #+19]
   \   000001B4   0xF010 0x00F1      ANDS     R0,R0,#0xF1
   \   000001B8   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000001BC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001BE   0x2214             MOVS     R2,#+20
   \   000001C0   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000001C4   0x74C8             STRB     R0,[R1, #+19]
   1281                      }
   1282                      break;
   \                     ??AntProcessMessage_21: (+1)
   \   000001C6   0xE02F             B.N      ??AntProcessMessage_19
   1283           
   1284                    default:
   1285                      G_au8AntMessageUnhandled[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_16: (+1)
   \   000001C8   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000001CC   0x3030             ADDS     R0,R0,#+48
   \   000001CE   0x.... 0x....      LDR.W    R1,??DataTable21_35
   \   000001D2   0x7308             STRB     R0,[R1, #+12]
   1286                      G_au8AntMessageUnhandled[24] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] >> 4) & 0x0F );
   \   000001D4   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000001D8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001DA   0x0900             LSRS     R0,R0,#+4
   \   000001DC   0x.... 0x....      BL       HexToASCIICharLower
   \   000001E0   0x.... 0x....      LDR.W    R1,??DataTable21_35
   \   000001E4   0x7608             STRB     R0,[R1, #+24]
   1287                      G_au8AntMessageUnhandled[25] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] & 0x0F) );
   \   000001E6   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000001EA   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000001EE   0x.... 0x....      BL       HexToASCIICharLower
   \   000001F2   0x.... 0x....      LDR.W    R1,??DataTable21_35
   \   000001F6   0x7648             STRB     R0,[R1, #+25]
   1288                      G_au8AntMessageUnhandled[36] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] >> 4) & 0x0F );
   \   000001F8   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000001FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FE   0x0900             LSRS     R0,R0,#+4
   \   00000200   0x.... 0x....      BL       HexToASCIICharLower
   \   00000204   0x.... 0x....      LDR.W    R1,??DataTable21_35
   \   00000208   0xF881 0x0024      STRB     R0,[R1, #+36]
   1289                      G_au8AntMessageUnhandled[37] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] & 0x0F) );
   \   0000020C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000210   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000214   0x.... 0x....      BL       HexToASCIICharLower
   \   00000218   0x.... 0x....      LDR.W    R1,??DataTable21_35
   \   0000021C   0xF881 0x0025      STRB     R0,[R1, #+37]
   1290                      DebugPrintf(G_au8AntMessageUnhandled);
   \   00000220   0x.... 0x....      LDR.W    R0,??DataTable21_35
   \   00000224   0x.... 0x....      BL       DebugPrintf
   1291                      break;
   1292                  } /* end switch */
   1293                  
   1294                  /* All messages print an "ok" or "fail" */
   1295                  if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR ) 
   \                     ??AntProcessMessage_19: (+1)
   \   00000228   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000022C   0x2800             CMP      R0,#+0
   \   0000022E   0xD104             BNE.N    ??AntProcessMessage_22
   1296                  {
   1297                    DebugPrintf(G_au8AntMessageOk);
   \   00000230   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \   00000234   0x.... 0x....      BL       DebugPrintf
   \   00000238   0xE093             B.N      ??AntProcessMessage_23
   1298                  }
   1299                  else
   1300                  {
   1301                    DebugPrintf(G_au8AntMessageFail);
   \                     ??AntProcessMessage_22: (+1)
   \   0000023A   0x.... 0x....      LDR.W    R0,??DataTable21_36
   \   0000023E   0x.... 0x....      BL       DebugPrintf
   1302                    G_u32AntFlags |= _ANT_FLAGS_CMD_ERROR;
   \   00000242   0x.... 0x....      LDR.W    R0,??DataTable21_22
   \   00000246   0x6800             LDR      R0,[R0, #+0]
   \   00000248   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000024C   0x.... 0x....      LDR.W    R1,??DataTable21_22
   \   00000250   0x6008             STR      R0,[R1, #+0]
   \   00000252   0xE086             B.N      ??AntProcessMessage_23
   1303                  }
   1304          
   1305                }
   1306                else /* The message is a Channel Event, so the Event Code must be parsed out */
   1307                { 
   1308                  switch ( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] )
   \                     ??AntProcessMessage_11: (+1)
   \   00000254   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000258   0x2800             CMP      R0,#+0
   \   0000025A   0xD00E             BEQ.N    ??AntProcessMessage_24
   \   0000025C   0x2801             CMP      R0,#+1
   \   0000025E   0xD059             BEQ.N    ??AntProcessMessage_25
   \   00000260   0x2802             CMP      R0,#+2
   \   00000262   0xD00E             BEQ.N    ??AntProcessMessage_26
   \   00000264   0x2803             CMP      R0,#+3
   \   00000266   0xD033             BEQ.N    ??AntProcessMessage_27
   \   00000268   0x2805             CMP      R0,#+5
   \   0000026A   0xD03D             BEQ.N    ??AntProcessMessage_28
   \   0000026C   0x2806             CMP      R0,#+6
   \   0000026E   0xD04D             BEQ.N    ??AntProcessMessage_29
   \   00000270   0x2807             CMP      R0,#+7
   \   00000272   0xD053             BEQ.N    ??AntProcessMessage_30
   \   00000274   0x2808             CMP      R0,#+8
   \   00000276   0xD027             BEQ.N    ??AntProcessMessage_31
   \   00000278   0xE063             B.N      ??AntProcessMessage_32
   1309                  {
   1310                    case RESPONSE_NO_ERROR: 
   1311                    {
   1312                      AntTickExtended(RESPONSE_NO_ERROR);
   \                     ??AntProcessMessage_24: (+1)
   \   0000027A   0x2000             MOVS     R0,#+0
   \   0000027C   0x.... 0x....      BL       AntTickExtended
   1313                      break;
   \   00000280   0xE06F             B.N      ??AntProcessMessage_23
   1314                    }
   1315          
   1316                    case EVENT_RX_FAIL: /* slave did not receive a message when expected */
   1317                    {
   1318                      /* The slave missed a message it was expecting: communicate this to the
   1319                      application in case it matters. Could also queue a debug message here. */
   1320                      if(++Ant_u8SlaveMissedMessageLow == 0)
   \                     ??AntProcessMessage_26: (+1)
   \   00000282   0x.... 0x....      LDR.W    R0,??DataTable21_37
   \   00000286   0x7800             LDRB     R0,[R0, #+0]
   \   00000288   0x1C40             ADDS     R0,R0,#+1
   \   0000028A   0x.... 0x....      LDR.W    R1,??DataTable21_37
   \   0000028E   0x7008             STRB     R0,[R1, #+0]
   \   00000290   0x.... 0x....      LDR.W    R0,??DataTable21_37
   \   00000294   0x7800             LDRB     R0,[R0, #+0]
   \   00000296   0x2800             CMP      R0,#+0
   \   00000298   0xD112             BNE.N    ??AntProcessMessage_33
   1321                      {
   1322                        if(++Ant_u8SlaveMissedMessageMid == 0)
   \   0000029A   0x.... 0x....      LDR.W    R0,??DataTable21_38
   \   0000029E   0x7800             LDRB     R0,[R0, #+0]
   \   000002A0   0x1C40             ADDS     R0,R0,#+1
   \   000002A2   0x.... 0x....      LDR.W    R1,??DataTable21_38
   \   000002A6   0x7008             STRB     R0,[R1, #+0]
   \   000002A8   0x.... 0x....      LDR.W    R0,??DataTable21_38
   \   000002AC   0x7800             LDRB     R0,[R0, #+0]
   \   000002AE   0x2800             CMP      R0,#+0
   \   000002B0   0xD106             BNE.N    ??AntProcessMessage_33
   1323                        {
   1324                          ++Ant_u8SlaveMissedMessageHigh;
   \   000002B2   0x.... 0x....      LDR.W    R0,??DataTable21_39
   \   000002B6   0x7800             LDRB     R0,[R0, #+0]
   \   000002B8   0x1C40             ADDS     R0,R0,#+1
   \   000002BA   0x.... 0x....      LDR.W    R1,??DataTable21_39
   \   000002BE   0x7008             STRB     R0,[R1, #+0]
   1325                        }
   1326                      }
   1327                      
   1328                      /* Queue an ANT_TICK message to the application message list. */
   1329                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_33: (+1)
   \   000002C0   0xA800             ADD      R0,SP,#+0
   \   000002C2   0x.... 0x....      BL       AntTickExtended
   1330                      break;
   \   000002C6   0xE04C             B.N      ??AntProcessMessage_23
   1331                    }
   1332          
   1333                    case EVENT_RX_FAIL_GO_TO_SEARCH: /* slave has lost sync with Master (channel still open) */
   1334                    {
   1335                      /* The slave missed enough consecutive messages so it goes back to search: communicate this to the
   1336                      application in case it matters. Could also queue a debug message here. */
   1337                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_31: (+1)
   \   000002C8   0xA800             ADD      R0,SP,#+0
   \   000002CA   0x.... 0x....      BL       AntTickExtended
   1338                      break;
   \   000002CE   0xE048             B.N      ??AntProcessMessage_23
   1339                    }
   1340          
   1341                    case EVENT_TX: /* ANT has sent a data message */
   1342                    {
   1343                      /* If this is a master device, then EVENT_TX means it's time to queue the 
   1344                      next message */
   1345                      if(G_asAntChannelConfiguration[u8Channel].AntChannelType == CHANNEL_TYPE_MASTER)
   \                     ??AntProcessMessage_27: (+1)
   \   000002D0   0x....             LDR.N    R0,??DataTable20_2
   \   000002D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002D4   0x2114             MOVS     R1,#+20
   \   000002D6   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000002DA   0x7840             LDRB     R0,[R0, #+1]
   \   000002DC   0x2810             CMP      R0,#+16
   \   000002DE   0xD102             BNE.N    ??AntProcessMessage_34
   1346                      {
   1347                        AntTickExtended(au8MessageCopy);
   \   000002E0   0xA800             ADD      R0,SP,#+0
   \   000002E2   0x.... 0x....      BL       AntTickExtended
   1348                      }
   1349                      break;
   \                     ??AntProcessMessage_34: (+1)
   \   000002E6   0xE03C             B.N      ??AntProcessMessage_23
   1350                    } 
   1351          
   1352                    case EVENT_TRANSFER_TX_COMPLETED: /* ACK received from an acknowledged data message */
   1353                    { 
   1354                      G_asAntChannelConfiguration[u8Channel].AntFlags |= _ANT_FLAGS_GOT_ACK;
   \                     ??AntProcessMessage_28: (+1)
   \   000002E8   0x....             LDR.N    R0,??DataTable20_2
   \   000002EA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002EC   0x2114             MOVS     R1,#+20
   \   000002EE   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000002F2   0x7CC0             LDRB     R0,[R0, #+19]
   \   000002F4   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000002F8   0x....             LDR.N    R1,??DataTable20_2
   \   000002FA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002FC   0x2214             MOVS     R2,#+20
   \   000002FE   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000302   0x74C8             STRB     R0,[R1, #+19]
   1355          
   1356                      AntTickExtended(au8MessageCopy);
   \   00000304   0xA800             ADD      R0,SP,#+0
   \   00000306   0x.... 0x....      BL       AntTickExtended
   1357                      break;
   \   0000030A   0xE02A             B.N      ??AntProcessMessage_23
   1358                    } 
   1359          
   1360                    case EVENT_TRANSFER_TX_FAILED: /* ACK was not received from an acknowledged data message */
   1361                    { 
   1362                      /* Regardless of complete or fail, it is time to send the next message */
   1363                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_29: (+1)
   \   0000030C   0xA800             ADD      R0,SP,#+0
   \   0000030E   0x.... 0x....      BL       AntTickExtended
   1364                      break;
   \   00000312   0xE026             B.N      ??AntProcessMessage_23
   1365                    } 
   1366          
   1367                    case EVENT_RX_SEARCH_TIMEOUT: /* The ANT channel is going to close due to search timeout */
   1368                    {
   1369                      /* Forward this to application */
   1370                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_25: (+1)
   \   00000314   0xA800             ADD      R0,SP,#+0
   \   00000316   0x.... 0x....      BL       AntTickExtended
   1371                      break;
   \   0000031A   0xE022             B.N      ??AntProcessMessage_23
   1372                    }
   1373           
   1374                    case EVENT_CHANNEL_CLOSED: /* The ANT channel is now closed */
   1375                    {
   1376                      DebugPrintf("Channel closed\n\r");
   \                     ??AntProcessMessage_30: (+1)
   \   0000031C   0x.... 0x....      LDR.W    R0,??DataTable21_40
   \   00000320   0x.... 0x....      BL       DebugPrintf
   1377                      G_asAntChannelConfiguration[u8Channel].AntFlags &= ~(_ANT_FLAGS_CHANNEL_CLOSE_PENDING | _ANT_FLAGS_CHANNEL_OPEN);
   \   00000324   0x....             LDR.N    R0,??DataTable20_2
   \   00000326   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000328   0x2114             MOVS     R1,#+20
   \   0000032A   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000032E   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000330   0xF010 0x00F3      ANDS     R0,R0,#0xF3
   \   00000334   0x....             LDR.N    R1,??DataTable20_2
   \   00000336   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000338   0x2214             MOVS     R2,#+20
   \   0000033A   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   0000033E   0x74C8             STRB     R0,[R1, #+19]
   1378                      break;
   \   00000340   0xE00F             B.N      ??AntProcessMessage_23
   1379                    }
   1380                    
   1381                    /* All other messages are unexpected for now */
   1382                    default:
   1383                      DebugPrintNumber(au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE]);
   \                     ??AntProcessMessage_32: (+1)
   \   00000342   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000346   0x.... 0x....      BL       DebugPrintNumber
   1384                      DebugPrintf(": unexpected channel event\n\r");
   \   0000034A   0x.... 0x....      LDR.W    R0,??DataTable21_41
   \   0000034E   0x.... 0x....      BL       DebugPrintf
   1385          
   1386                      G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_EVENT;
   \   00000352   0x.... 0x....      LDR.W    R0,??DataTable21_22
   \   00000356   0x6800             LDR      R0,[R0, #+0]
   \   00000358   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000035C   0x.... 0x....      LDR.W    R1,??DataTable21_22
   \   00000360   0x6008             STR      R0,[R1, #+0]
   1387                      break;
   1388                  } /* end Ant_pu8AntRxBufferUnreadMsg[EVENT_CODE_INDEX] */
   1389                } /* end else RF event */
   1390                
   1391                break; 
   \                     ??AntProcessMessage_23: (+1)
   \   00000362   0xE037             B.N      ??AntProcessMessage_35
   1392              } /* end case MESG_RESPONSE_EVENT_ID */
   1393          
   1394              case MESG_ACKNOWLEDGED_DATA_ID: /* An acknowledged data message was received */
   1395              /* Fall through */
   1396                
   1397              case MESG_BROADCAST_DATA_ID: /* A broadcast data message was received */
   1398              { 
   1399                /* Parse the extended data and put the message to the application buffer */
   1400                AntParseExtendedData(au8MessageCopy, &sExtendedData);
   \                     ??AntProcessMessage_7: (+1)
   \   00000364   0xA905             ADD      R1,SP,#+20
   \   00000366   0xA800             ADD      R0,SP,#+0
   \   00000368   0x.... 0x....      BL       AntParseExtendedData
   1401                AntQueueExtendedApplicationMessage(ANT_DATA, &au8MessageCopy[BUFFER_INDEX_MESG_DATA], &sExtendedData);
   \   0000036C   0xAA05             ADD      R2,SP,#+20
   \   0000036E   0xF10D 0x0103      ADD      R1,SP,#+3
   \   00000372   0x2001             MOVS     R0,#+1
   \   00000374   0x.... 0x....      BL       AntQueueExtendedApplicationMessage
   1402                
   1403                /* If this is a slave device, then a data message received means it's time to send */
   1404                if(G_asAntChannelConfiguration[u8Channel].AntChannelType == CHANNEL_TYPE_SLAVE)
   \   00000378   0x....             LDR.N    R0,??DataTable20_2
   \   0000037A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000037C   0x2114             MOVS     R1,#+20
   \   0000037E   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000382   0x7840             LDRB     R0,[R0, #+1]
   \   00000384   0x2800             CMP      R0,#+0
   \   00000386   0xD102             BNE.N    ??AntProcessMessage_36
   1405                {
   1406                  AntTickExtended(RESPONSE_NO_ERROR);
   \   00000388   0x2000             MOVS     R0,#+0
   \   0000038A   0x.... 0x....      BL       AntTickExtended
   1407                }
   1408                
   1409                break;
   \                     ??AntProcessMessage_36: (+1)
   \   0000038E   0xE021             B.N      ??AntProcessMessage_35
   1410              } /* end case MESG_BROADCAST_DATA_ID */
   1411              
   1412              case MESG_CHANNEL_STATUS_ID: /* Message sent in response to a channel status request */
   1413              { 
   1414                break;
   \                     ??AntProcessMessage_8: (+1)
   \   00000390   0xE020             B.N      ??AntProcessMessage_35
   1415              } /* end case ChannelStatus_CMD */
   1416              
   1417              case MESG_VERSION_ID:
   1418              {
   1419                for(u8 i = 0; i < MESG_VERSION_SIZE; i++)
   \                     ??AntProcessMessage_5: (+1)
   \   00000392   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_37: (+1)
   \   00000394   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000396   0x280A             CMP      R0,#+10
   \   00000398   0xDA08             BGE.N    ??AntProcessMessage_38
   1420                {
   1421                  Ant_u8AntVersion[i] = au8MessageCopy[BUFFER_INDEX_VERSION_BYTE0 + i];
   \   0000039A   0xA900             ADD      R1,SP,#+0
   \   0000039C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000039E   0x1841             ADDS     R1,R0,R1
   \   000003A0   0x7889             LDRB     R1,[R1, #+2]
   \   000003A2   0x....             LDR.N    R2,??DataTable21_5
   \   000003A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003A6   0x5481             STRB     R1,[R0, R2]
   1422                }
   \   000003A8   0x1C40             ADDS     R0,R0,#+1
   \   000003AA   0xE7F3             B.N      ??AntProcessMessage_37
   1423                
   1424                /* If we get a version message, we know that ANT comms is good */
   1425                G_u32ApplicationFlags |= _APPLICATION_FLAGS_ANT;
   \                     ??AntProcessMessage_38: (+1)
   \   000003AC   0x....             LDR.N    R0,??DataTable21_3
   \   000003AE   0x6800             LDR      R0,[R0, #+0]
   \   000003B0   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000003B4   0x....             LDR.N    R1,??DataTable21_3
   \   000003B6   0x6008             STR      R0,[R1, #+0]
   1426                
   1427                break;
   \   000003B8   0xE00C             B.N      ??AntProcessMessage_35
   1428              } /* end case MESG_VERSION_ID */
   1429          
   1430              case MESG_RESTART_ID:
   1431              {
   1432                G_u32AntFlags |= _ANT_FLAGS_RESTART;  
   \                     ??AntProcessMessage_9: (+1)
   \   000003BA   0x....             LDR.N    R0,??DataTable21_22
   \   000003BC   0x6800             LDR      R0,[R0, #+0]
   \   000003BE   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   000003C2   0x....             LDR.N    R1,??DataTable21_22
   \   000003C4   0x6008             STR      R0,[R1, #+0]
   1433                break;
   \   000003C6   0xE005             B.N      ??AntProcessMessage_35
   1434              } /* end case MESG_RESTART_ID */
   1435              
   1436              default:
   1437                G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_MSG;
   \                     ??AntProcessMessage_10: (+1)
   \   000003C8   0x....             LDR.N    R0,??DataTable21_22
   \   000003CA   0x6800             LDR      R0,[R0, #+0]
   \   000003CC   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000003D0   0x....             LDR.N    R1,??DataTable21_22
   \   000003D2   0x6008             STR      R0,[R1, #+0]
   1438                break;
   1439            } /* end switch( Ant_pu8AntRxBufferUnreadMsg[MESG_ID_OFFSET] ) */
   1440                     
   1441            return(0);
   \                     ??AntProcessMessage_35: (+1)
   \   000003D4   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_1: (+1)
   \   000003D6   0xB008             ADD      SP,SP,#+32
   \   000003D8   0xBD70             POP      {R4-R6,PC}       ;; return
   1442            
   1443          } /* end AntProcessMessage() */
   1444          
   1445          
   1446          /*-----------------------------------------------------------------------------/
   1447          Function: AntTickExtended
   1448          
   1449          Description:
   1450          Queues an ANT_TICK message to the application message queue.
   1451          
   1452          Requires:
   1453            - u8Code_ is payload byte indicating system info that may be relavent to the application
   1454          
   1455          Promises:
   1456            - A MESSAGE_ANT_TICK is queued to G_sAntApplicationMsgList
   1457          */

   \                                 In section .text, align 2, keep-with-next
   1458          static void AntTickExtended(u8* pu8AntMessage_)
   1459          {
   \                     AntTickExtended: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1460            u8 au8Message[ANT_APPLICATION_MESSAGE_BYTES];
   1461            AntExtendedDataType sExtData;
   1462          
   1463            /* Update data to communicate the ANT_TICK to the application */
   1464            au8Message[ANT_TICK_MSG_ID_INDEX]               = MESSAGE_ANT_TICK;
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1465            au8Message[ANT_TICK_MSG_CHANNEL_INDEX]          = *(pu8AntMessage_ + BUFFER_INDEX_CHANNEL_NUM);
   \   0000000A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1466            au8Message[ANT_TICK_MSG_RESPONSE_TYPE_INDEX]    = *(pu8AntMessage_ + BUFFER_INDEX_RESPONSE_MESG_ID);
   \   00000010   0x78E0             LDRB     R0,[R4, #+3]
   \   00000012   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1467            au8Message[ANT_TICK_MSG_EVENT_CODE_INDEX]       = *(pu8AntMessage_ + BUFFER_INDEX_RESPONSE_CODE);
   \   00000016   0x7920             LDRB     R0,[R4, #+4]
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1468            au8Message[ANT_TICK_MSG_SENTINEL3_INDEX]        = MESSAGE_ANT_TICK;
   \   0000001C   0x20FF             MOVS     R0,#+255
   \   0000001E   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1469            au8Message[ANT_TICK_MSG_MISSED_HIGH_BYTE_INDEX] = Ant_u8SlaveMissedMessageHigh;
   \   00000022   0x....             LDR.N    R0,??DataTable21_39
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1470            au8Message[ANT_TICK_MSG_MISSED_MID_BYTE_INDEX]  = Ant_u8SlaveMissedMessageMid;
   \   0000002A   0x....             LDR.N    R0,??DataTable21_38
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1471            au8Message[ANT_TICK_MSG_MISSED_LOW_BYTE_INDEX]  = Ant_u8SlaveMissedMessageLow;
   \   00000032   0x....             LDR.N    R0,??DataTable21_37
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1472          
   1473            /* Extended data is not valid for an ANT_TICK message */
   1474            sExtData.u8Channel    = au8Message[ANT_TICK_MSG_CHANNEL_INDEX];
   \   0000003A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000003E   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1475            sExtData.u16DeviceID  = 0xFF;
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1476            sExtData.u8DeviceType = 0xFF;
   \   00000048   0x20FF             MOVS     R0,#+255
   \   0000004A   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1477            sExtData.u8TransType  = 0xFF;
   \   0000004E   0x20FF             MOVS     R0,#+255
   \   00000050   0xF88D 0x000D      STRB     R0,[SP, #+13]
   1478            sExtData.s8RSSI       = 0xFF;
   \   00000054   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000058   0xF88D 0x000E      STRB     R0,[SP, #+14]
   1479            sExtData.u8Flags      = 0xFF;
   \   0000005C   0x20FF             MOVS     R0,#+255
   \   0000005E   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1480            
   1481            /* Data is ready so queue it in to the application buffer */
   1482            AntQueueExtendedApplicationMessage(ANT_TICK, 
   1483                                               &au8Message[ANT_TICK_MSG_ID_INDEX],
   1484                                               &sExtData);
   \   00000062   0xAA02             ADD      R2,SP,#+8
   \   00000064   0xA900             ADD      R1,SP,#+0
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x.... 0x....      BL       AntQueueExtendedApplicationMessage
   1485          
   1486          } /* end AntTickExtended() */
   \   0000006C   0xBD1F             POP      {R0-R4,PC}       ;; return
   1487          
   1488          
   1489          /*-----------------------------------------------------------------------------/
   1490          Function: AntQueueExtendedApplicationMessage
   1491          
   1492          Description:
   1493          Creates a new ANT data message structure and adds it to G_sAntApplicationMsgList.
   1494          The Application list used to communicate message information between the ANT driver and
   1495          the ANT_API simplified interface task.
   1496          
   1497          Requires:
   1498            - eMessageType_ specifies the type of message
   1499            - pu8DataSource_ is a pointer to the first element of an array of 8 data bytes
   1500            - psTargetList_ is a pointer to the list pointer that is being updated
   1501            - Enough space is available on the heap
   1502          
   1503          Promises:
   1504            - A new list item in the target linked list is created and inserted at the end
   1505              of the list.
   1506            - Returns TRUE if the entry is added successfully.
   1507            - Returns FALSE if the malloc fails or the list is full.
   1508          */

   \                                 In section .text, align 2, keep-with-next
   1509          static bool AntQueueExtendedApplicationMessage(AntApplicationMessageType eMessageType_, 
   1510                                                         u8* pu8DataSource_, 
   1511                                                         AntExtendedDataType* psExtData_)
   1512          {
   \                     AntQueueExtendedApplicationMessage: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   1513            AntApplicationMsgListType *psNewMessage;
   1514            AntApplicationMsgListType *psListParser;
   1515            u8 u8MessageCount = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   1516            u8 au8AddMessageFailMsg[] = "\n\rNo space in AntQueueApplicationMessage\n\r";
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x....             LDR.N    R1,??DataTable21_42
   \   00000014   0x222B             MOVS     R2,#+43
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy
   1517            
   1518            /* Allocate space for the new message - always do maximum message size */
   1519            psNewMessage = malloc( sizeof(AntApplicationMsgListType) );
   \   0000001A   0x201C             MOVS     R0,#+28
   \   0000001C   0x.... 0x....      BL       malloc
   \   00000020   0x0007             MOVS     R7,R0
   1520            if (psNewMessage == NULL)
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xD104             BNE.N    ??AntQueueExtendedApplicationMessage_0
   1521            {
   1522              DebugPrintf(au8AddMessageFailMsg);
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x.... 0x....      BL       DebugPrintf
   1523              return(FALSE);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE047             B.N      ??AntQueueExtendedApplicationMessage_1
   1524            }
   1525            
   1526            /* Fill in all the fields of the newly allocated message structure */
   1527            for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \                     ??AntQueueExtendedApplicationMessage_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??AntQueueExtendedApplicationMessage_2: (+1)
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xDA06             BGE.N    ??AntQueueExtendedApplicationMessage_3
   1528            {
   1529              psNewMessage->au8MessageData[i] = *(pu8DataSource_ + i);
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x5D41             LDRB     R1,[R0, R5]
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x19C2             ADDS     R2,R0,R7
   \   00000040   0x7191             STRB     R1,[R2, #+6]
   1530            }
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0xE7F5             B.N      ??AntQueueExtendedApplicationMessage_2
   1531            
   1532            /* Copy basic items */
   1533            psNewMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueExtendedApplicationMessage_3: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable21_43
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x6038             STR      R0,[R7, #+0]
   1534            psNewMessage->eMessageType  = eMessageType_;
   \   0000004C   0x713C             STRB     R4,[R7, #+4]
   1535            
   1536            /* Copy all extended data fields */
   1537            psNewMessage->sExtendedData.u8Channel    = psExtData_->u8Channel;
   \   0000004E   0x7830             LDRB     R0,[R6, #+0]
   \   00000050   0x73B8             STRB     R0,[R7, #+14]
   1538            psNewMessage->sExtendedData.u16DeviceID  = psExtData_->u16DeviceID;
   \   00000052   0x8870             LDRH     R0,[R6, #+2]
   \   00000054   0x8238             STRH     R0,[R7, #+16]
   1539            psNewMessage->sExtendedData.u8DeviceType = psExtData_->u8DeviceType;
   \   00000056   0x7930             LDRB     R0,[R6, #+4]
   \   00000058   0x74B8             STRB     R0,[R7, #+18]
   1540            psNewMessage->sExtendedData.u8TransType  = psExtData_->u8TransType;
   \   0000005A   0x7970             LDRB     R0,[R6, #+5]
   \   0000005C   0x74F8             STRB     R0,[R7, #+19]
   1541            psNewMessage->sExtendedData.u8Flags      = psExtData_->u8Flags;
   \   0000005E   0x7870             LDRB     R0,[R6, #+1]
   \   00000060   0x73F8             STRB     R0,[R7, #+15]
   1542            psNewMessage->sExtendedData.s8RSSI       = psExtData_->s8RSSI;
   \   00000062   0x79B0             LDRB     R0,[R6, #+6]
   \   00000064   0x7538             STRB     R0,[R7, #+20]
   1543              
   1544            psNewMessage->psNextMessage = NULL;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x61B8             STR      R0,[R7, #+24]
   1545          
   1546            /* Insert into an empty list */
   1547            if(G_sAntApplicationMsgList == NULL)
   \   0000006A   0x....             LDR.N    R0,??DataTable21
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD107             BNE.N    ??AntQueueExtendedApplicationMessage_4
   1548            {
   1549              G_sAntApplicationMsgList = psNewMessage;
   \   00000072   0x....             LDR.N    R0,??DataTable21
   \   00000074   0x6007             STR      R7,[R0, #+0]
   1550              Ant_u32ApplicationMessageCount++;
   \   00000076   0x....             LDR.N    R0,??DataTable21_26
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x....             LDR.N    R1,??DataTable21_26
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   \   00000080   0xE01D             B.N      ??AntQueueExtendedApplicationMessage_5
   1551            }
   1552          
   1553            /* Otherwise traverse the list to find the end where the new message will be inserted */
   1554            else
   1555            {
   1556              psListParser = G_sAntApplicationMsgList;
   \                     ??AntQueueExtendedApplicationMessage_4: (+1)
   \   00000082   0x....             LDR.N    R0,??DataTable21
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x4680             MOV      R8,R0
   1557              while(psListParser->psNextMessage != NULL) 
   \                     ??AntQueueExtendedApplicationMessage_6: (+1)
   \   00000088   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD004             BEQ.N    ??AntQueueExtendedApplicationMessage_7
   1558              {
   1559                psListParser = psListParser->psNextMessage;
   \   00000090   0xF8D8 0x8018      LDR      R8,[R8, #+24]
   1560                u8MessageCount++;
   \   00000094   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000098   0xE7F6             B.N      ??AntQueueExtendedApplicationMessage_6
   1561              }
   1562              
   1563              /* Check for full list */
   1564              if(u8MessageCount < ANT_APPLICATION_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueExtendedApplicationMessage_7: (+1)
   \   0000009A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000009E   0xF1B9 0x0F20      CMP      R9,#+32
   \   000000A2   0xD207             BCS.N    ??AntQueueExtendedApplicationMessage_8
   1565              {
   1566                /* Insert the new message at the end of the list */
   1567                psListParser->psNextMessage = psNewMessage;
   \   000000A4   0xF8C8 0x7018      STR      R7,[R8, #+24]
   1568                Ant_u32ApplicationMessageCount++;
   \   000000A8   0x....             LDR.N    R0,??DataTable21_26
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x....             LDR.N    R1,??DataTable21_26
   \   000000B0   0x6008             STR      R0,[R1, #+0]
   \   000000B2   0xE004             B.N      ??AntQueueExtendedApplicationMessage_5
   1569              }
   1570              /* Handle a full list */
   1571              else
   1572              {
   1573                DebugPrintf(au8AddMessageFailMsg);
   \                     ??AntQueueExtendedApplicationMessage_8: (+1)
   \   000000B4   0xA800             ADD      R0,SP,#+0
   \   000000B6   0x.... 0x....      BL       DebugPrintf
   1574                return(FALSE);
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE000             B.N      ??AntQueueExtendedApplicationMessage_1
   1575              }
   1576            }
   1577              
   1578            return(TRUE);
   \                     ??AntQueueExtendedApplicationMessage_5: (+1)
   \   000000BE   0x2001             MOVS     R0,#+1
   \                     ??AntQueueExtendedApplicationMessage_1: (+1)
   \   000000C0   0xB00B             ADD      SP,SP,#+44
   \   000000C2   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1579              
   1580          } /* end AntQueueExtendedApplicationMessage() */
   1581          
   1582          
   1583          /*-----------------------------------------------------------------------------/
   1584          Function: AntDeQueueOutgoingMessage
   1585          
   1586          Description:
   1587          Removes the first entry of Ant_psDataOutgoingMsgList.
   1588          
   1589          Requires:
   1590            - 
   1591          
   1592          Promises:
   1593            - Ant_psDataOutgoingMsgList = Ant_psDataOutgoingMsgList->psNextMessage 
   1594            and the memory is freed
   1595          */

   \                                 In section .text, align 2, keep-with-next
   1596          static void AntDeQueueOutgoingMessage(void)
   1597          {
   \                     AntDeQueueOutgoingMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1598            AntOutgoingMessageListType *psMessageToKill;
   1599            
   1600            if(Ant_psDataOutgoingMsgList != NULL)
   \   00000002   0x....             LDR.N    R0,??DataTable21_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00A             BEQ.N    ??AntDeQueueOutgoingMessage_0
   1601            {
   1602              psMessageToKill = Ant_psDataOutgoingMsgList;
   \   0000000A   0x....             LDR.N    R0,??DataTable21_1
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0004             MOVS     R4,R0
   1603              Ant_psDataOutgoingMsgList = Ant_psDataOutgoingMsgList->psNextMessage;
   \   00000010   0x....             LDR.N    R0,??DataTable21_1
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6980             LDR      R0,[R0, #+24]
   \   00000016   0x....             LDR.N    R1,??DataTable21_1
   \   00000018   0x6008             STR      R0,[R1, #+0]
   1604            
   1605              /* The doomed message is properly disconnected, so kill it */
   1606              free(psMessageToKill);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       free
   1607            }
   1608            
   1609          } /* end AntDeQueueOutgoingMessage() */
   \                     ??AntDeQueueOutgoingMessage_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
   1610          
   1611          
   1612          /***********************************************************************************************************************
   1613          ##### ANT State Machine Definition                                             
   1614          ***********************************************************************************************************************/
   1615          
   1616          /*------------------------------------------------------------------------------
   1617          Idle state that will process new messages if any are present, monitors ANT
   1618          for incoming messages, and sends broadcast messages that are waiting to be sent.
   1619          Incoming messages from ANT always get priority.  
   1620          */

   \                                 In section .text, align 2, keep-with-next
   1621          void AntSM_Idle(void)
   1622          {
   \                     AntSM_Idle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1623            u32 u32MsgBitMask = 0x01;
   \   00000002   0x2401             MOVS     R4,#+1
   1624            u8 u8MsgIndex = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1625            static u8 au8AntFlagAlert[] = "ANT flags:\n\r"; 
   1626            
   1627            /* Error messages: must match order of G_u32AntFlags Error / event flags */
   1628            static u8 au8AntFlagMessages[][20] = 
   1629            {/* "012345678901234567\n\r" */
   1630                "Length mismatch\n\r",
   1631                "Command error\n\r",
   1632                "Unexpected event\n\r",
   1633                "Unexpected message\n\r"
   1634            };
   1635            
   1636            /* Check flags */
   1637            if(G_u32AntFlags & ANT_ERROR_FLAGS_MASK)
   \   00000006   0x....             LDR.N    R0,??DataTable21_22
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0400             LSLS     R0,R0,#+16
   \   0000000C   0xD01B             BEQ.N    ??AntSM_Idle_0
   1638            {
   1639              /* At least one flag is set, so print header and parse out */
   1640              DebugPrintf(au8AntFlagAlert);
   \   0000000E   0x....             LDR.N    R0,??DataTable21_44
   \   00000010   0x.... 0x....      BL       DebugPrintf
   1641              for(u8 i = 0; i < ANT_ERROR_FLAGS_COUNT; i++)
   \   00000014   0x2600             MOVS     R6,#+0
   \                     ??AntSM_Idle_1: (+1)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E04             CMP      R6,#+4
   \   0000001A   0xDA0E             BGE.N    ??AntSM_Idle_2
   1642              {
   1643                /* Check if current flag is set */
   1644                if(G_u32AntFlags & u32MsgBitMask)
   \   0000001C   0x....             LDR.N    R0,??DataTable21_22
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4220             TST      R0,R4
   \   00000022   0xD006             BEQ.N    ??AntSM_Idle_3
   1645                {
   1646                  /* Print the error message */
   1647                  DebugPrintf(au8AntFlagMessages[u8MsgIndex]);
   \   00000024   0x....             LDR.N    R0,??DataTable21_45
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2114             MOVS     R1,#+20
   \   0000002A   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000002E   0x.... 0x....      BL       DebugPrintf
   1648                }
   1649                u32MsgBitMask <<= 1;
   \                     ??AntSM_Idle_3: (+1)
   \   00000032   0x0064             LSLS     R4,R4,#+1
   1650                u8MsgIndex++;
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   1651              }
   \   00000036   0x1C76             ADDS     R6,R6,#+1
   \   00000038   0xE7ED             B.N      ??AntSM_Idle_1
   1652              
   1653              /* Clear all the error flags now that they have been reported */
   1654              G_u32AntFlags &= ~ANT_ERROR_FLAGS_MASK;
   \                     ??AntSM_Idle_2: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable21_22
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x0C00             LSRS     R0,R0,#+16
   \   00000040   0x0400             LSLS     R0,R0,#+16
   \   00000042   0x....             LDR.N    R1,??DataTable21_22
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1655            }
   1656            
   1657            /* Process messages received from ANT */
   1658            AntProcessMessage();
   \                     ??AntSM_Idle_0: (+1)
   \   00000046   0x.... 0x....      BL       AntProcessMessage
   1659          
   1660            /* Handle messages coming in from ANT */
   1661            if( IS_SEN_ASSERTED() )
   \   0000004A   0x....             LDR.N    R0,??DataTable21_46
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x07C0             LSLS     R0,R0,#+31
   \   00000050   0xD504             BPL.N    ??AntSM_Idle_4
   1662            {
   1663              Ant_pfnStateMachine = AntSM_ReceiveMessage;
   \   00000052   0x.... 0x....      ADR.W    R0,AntSM_ReceiveMessage
   \   00000056   0x....             LDR.N    R1,??DataTable20_1
   \   00000058   0x6008             STR      R0,[R1, #+0]
   \   0000005A   0xE016             B.N      ??AntSM_Idle_5
   1664            }
   1665            
   1666            /* Send a message if the system is ready and there is one to send */ 
   1667            else if( (Ant_u32CurrentTxMessageToken == 0 ) && 
   1668                     (Ant_psDataOutgoingMsgList != NULL) )
   \                     ??AntSM_Idle_4: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable21_18
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD112             BNE.N    ??AntSM_Idle_5
   \   00000064   0x....             LDR.N    R0,??DataTable21_1
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD00E             BEQ.N    ??AntSM_Idle_5
   1669            {
   1670              /* Give the message to AntTx which will set Ant_u32CurrentTxMessageToken */
   1671              if(AntTxMessage(Ant_psDataOutgoingMsgList->au8MessageData))
   \   0000006C   0x....             LDR.N    R0,??DataTable21_1
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x1D00             ADDS     R0,R0,#+4
   \   00000072   0x.... 0x....      BL       AntTxMessage
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD007             BEQ.N    ??AntSM_Idle_5
   1672              {
   1673                Ant_u32TxTimer = G_u32SystemTime1ms;
   \   0000007A   0x....             LDR.N    R0,??DataTable21_43
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x....             LDR.N    R1,??DataTable21_47
   \   00000080   0x6008             STR      R0,[R1, #+0]
   1674                Ant_pfnStateMachine = AntSM_TransmitMessage;
   \   00000082   0x.... 0x....      ADR.W    R0,AntSM_TransmitMessage
   \   00000086   0x....             LDR.N    R1,??DataTable20_1
   \   00000088   0x6008             STR      R0,[R1, #+0]
   1675              }
   1676              else
   1677              {
   1678                /* Transmit attempt failed.  !!!! Do something? */
   1679              }
   1680            }
   1681            
   1682          } /* end AntSM_Idle() */
   \                     ??AntSM_Idle_5: (+1)
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??au8AntFlagAlert:
   \   00000000   0x41 0x4E          DC8 "ANT flags:\012\015"
   \              0x54 0x20    
   \              0x66 0x6C    
   \              0x61 0x67    
   \              0x73 0x3A    
   \              0x0A 0x0D    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     ??au8AntFlagMessages:
   \   00000000   0x4C 0x65          DC8 "Length mismatch\012\015"
   \              0x6E 0x67    
   \              0x74 0x68    
   \              0x20 0x6D    
   \              0x69 0x73    
   \              0x6D 0x61    
   \              0x74 0x63    
   \              0x68 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
   \   00000014   0x43 0x6F          DC8 "Command error\012\015"
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x0A    
   \              0x0D 0x00    
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000028   0x55 0x6E          DC8 "Unexpected event\012\015"
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000003B   0x00               DC8 0
   \   0000003C   0x55 0x6E          DC8 55H, 6EH, 65H, 78H, 70H, 65H, 63H, 74H
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \   00000044   0x65 0x64          DC8 65H, 64H, 20H, 6DH, 65H, 73H, 73H, 61H
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \   0000004C   0x67 0x65          DC8 67H, 65H, 0AH, 0DH
   \              0x0A 0x0D    
   1683          
   1684          
   1685          /*------------------------------------------------------------------------------
   1686          Completely receive an ANT message.  Reception is very fast and should complete
   1687          in less than 600us for a 15-byte message.  AntRxMessage could just be called from Idle,
   1688          but giving it its own state minimizes the total time and allows for easier future
   1689          updates should they be required.
   1690          */

   \                                 In section .text, align 4, keep-with-next
   1691          void AntSM_ReceiveMessage(void)
   1692          {
   \                     AntSM_ReceiveMessage: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1693            Ant_DebugRxMessageCounter++;
   \   00000002   0x....             LDR.N    R0,??DataTable21_48
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable21_48
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1694            AntRxMessage();
   \   0000000C   0x.... 0x....      BL       AntRxMessage
   1695            
   1696            Ant_pfnStateMachine = AntSM_Idle;
   \   00000010   0x....             LDR.N    R0,??DataTable21_6
   \   00000012   0x....             LDR.N    R1,??DataTable20_1
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1697          
   1698          } /* end AntSM_ReceiveMessage() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
   1699          
   1700          
   1701          /*------------------------------------------------------------------------------
   1702          Wait for an ANT message to be transmitted.  This state only occurs once the 
   1703          handshaking transaction has been completed and transmit to ANT is verified 
   1704          and underway.
   1705          */

   \                                 In section .text, align 4, keep-with-next
   1706          void AntSM_TransmitMessage(void)
   1707          {
   \                     AntSM_TransmitMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1708            static u8 au8TxTimeoutMsg[] = "\n\rTransmit message timeout\n\r";
   1709            MessageStateType eCurrentMsgStatus;
   1710            
   1711            eCurrentMsgStatus = QueryMessageStatus(Ant_u32CurrentTxMessageToken);
   \   00000002   0x....             LDR.N    R0,??DataTable21_18
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       QueryMessageStatus
   \   0000000A   0x0004             MOVS     R4,R0
   1712            switch(eCurrentMsgStatus)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x1F00             SUBS     R0,R0,#+4
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD82E             BHI.N    ??AntSM_TransmitMessage_0
   1713            {
   1714              case TIMEOUT:
   1715                /* Fall through */
   1716                
   1717              case COMPLETE:
   1718                /* Kill the message and update flags */
   1719                AntDeQueueOutgoingMessage();
   \                     ??AntSM_TransmitMessage_1: (+1)
   \   00000016   0x.... 0x....      BL       AntDeQueueOutgoingMessage
   1720                Ant_u32CurrentTxMessageToken = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable21_18
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1721                G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \   00000020   0x....             LDR.N    R0,??DataTable21_22
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF030 0x6000      BICS     R0,R0,#0x8000000
   \   00000028   0x....             LDR.N    R1,??DataTable21_22
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1722          
   1723                /* Wait for SEN to deassert so we know ANT is totally ready for the next
   1724                transaction.  This takes about 170us, so block in this state until that's over */
   1725                while ( IS_SEN_ASSERTED() && (Ant_u32TxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntSM_TransmitMessage_2: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable21_46
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x07C0             LSLS     R0,R0,#+31
   \   00000032   0xD50B             BPL.N    ??AntSM_TransmitMessage_3
   \   00000034   0x....             LDR.N    R0,??DataTable21_47
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF242 0x7110      MOVW     R1,#+10000
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD205             BCS.N    ??AntSM_TransmitMessage_3
   1726                {
   1727                  Ant_u32TxTimer++;
   \   00000040   0x....             LDR.N    R0,??DataTable21_47
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x....             LDR.N    R1,??DataTable21_47
   \   00000048   0x6008             STR      R0,[R1, #+0]
   \   0000004A   0xE7EF             B.N      ??AntSM_TransmitMessage_2
   1728                }
   1729          
   1730                /* If we timed out, then ANT is stuck so print error and unstick ANT */
   1731                if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \                     ??AntSM_TransmitMessage_3: (+1)
   \   0000004C   0x....             LDR.N    R0,??DataTable21_49
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF242 0x7111      MOVW     R1,#+10001
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD309             BCC.N    ??AntSM_TransmitMessage_4
   1732                {
   1733                  DebugPrintf(au8TxTimeoutMsg);
   \   00000058   0x....             LDR.N    R0,??DataTable21_50
   \   0000005A   0x.... 0x....      BL       DebugPrintf
   1734                  while( IS_SEN_ASSERTED() )
   \                     ??AntSM_TransmitMessage_5: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable21_46
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x07C0             LSLS     R0,R0,#+31
   \   00000064   0xD502             BPL.N    ??AntSM_TransmitMessage_4
   1735                  {
   1736                    AntSrdyPulse();
   \   00000066   0x.... 0x....      BL       AntSrdyPulse
   \   0000006A   0xE7F8             B.N      ??AntSM_TransmitMessage_5
   1737                  }
   1738                }
   1739                
   1740                Ant_pfnStateMachine = AntSM_Idle;
   \                     ??AntSM_TransmitMessage_4: (+1)
   \   0000006C   0x....             LDR.N    R0,??DataTable21_6
   \   0000006E   0x....             LDR.N    R1,??DataTable21_51
   \   00000070   0x6008             STR      R0,[R1, #+0]
   1741                break;
   \   00000072   0xE7FF             B.N      ??AntSM_TransmitMessage_6
   1742                
   1743              default:
   1744                /* Do nothing for now */
   1745                break;
   1746                
   1747            } /* end switch */
   1748            
   1749          } /* end AntSM_TransmitMessage() */
   \                     ??AntSM_TransmitMessage_0: (+1)
   \                     ??AntSM_TransmitMessage_6: (+1)
   \   00000074   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .data, align 4
   \                     ??au8TxTimeoutMsg:
   \   00000000   0x0A 0x0D          DC8 "\012\015Transmit message timeout\012\015"
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6D    
   \              0x69 0x74    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1750          
   1751          
   1752          /*------------------------------------------------------------------------------
   1753          Do-nothing state if ANT is dead (requires restart to retry initialization)
   1754          */

   \                                 In section .text, align 2, keep-with-next
   1755          void AntSM_NoResponse(void)
   1756          {
   1757            
   1758          } /* end AntSM_NoResponse() */
   \                     AntSM_NoResponse: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferCurrentChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferUnreadMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     Ant_u8AntNewRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x400E0E34         DC32     0x400e0e34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x400E0E30         DC32     0x400e0e30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \   00000000   0x........         DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \   00000000   0x........         DC32     G_au8ANTGetVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \   00000000   0x........         DC32     Ant_u32RxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \   00000000   0x........         DC32     Ant_u32RxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \   00000000   0x........         DC32     Ant_DebugTotalRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \   00000000   0x........         DC32     Ant_u32RxTimeoutCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_17:
   \   00000000   0x........         DC32     Ant_u32UnexpectedByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer+0x100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     G_au8AntMessageNoAnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     AntSM_NoResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x400E0E10         DC32     0x400e0e10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x........         DC32     G_au8AntMessageInit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     Ant_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     G_asAntChannelConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     Ant_sSspConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x400E0E00         DC32     0x400e0e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     G_sAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     Ant_psDataOutgoingMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x........         DC32     Ant_Ssp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x........         DC32     G_au8AntMessageOk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x........         DC32     Ant_u8AntVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \   00000000   0x........         DC32     AntSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \   00000000   0x........         DC32     G_au8AntMessageInitFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_8:
   \   00000000   0x400E0C04         DC32     0x400e0c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_9:
   \   00000000   0x400E0C00         DC32     0x400e0c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_10:
   \   00000000   0x400E0E04         DC32     0x400e0e04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_11:
   \   00000000   0x400E0C14         DC32     0x400e0c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_12:
   \   00000000   0x400E0E14         DC32     0x400e0e14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_13:
   \   00000000   0x........         DC32     G_u32SystemTime1s

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_14:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_15:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_16:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_17:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_18:
   \   00000000   0x........         DC32     Ant_u32CurrentTxMessageToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_19:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_20:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferUnreadMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_21:
   \   00000000   0x........         DC32     Ant_u32TxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_22:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_23:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_24:
   \   00000000   0x........         DC32     Ant_DebugQueuedDataMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_25:
   \   00000000   0x........         DC32     Ant_u32OutgoingMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_26:
   \   00000000   0x........         DC32     Ant_u32ApplicationMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_27:
   \   00000000   0x........         DC32     Ant_u8AntNewRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_28:
   \   00000000   0x........         DC32     Ant_DebugProcessRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_29:
   \   00000000   0x........         DC32     G_stMessageResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_30:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_31:
   \   00000000   0x........         DC32     G_au8AntMessageOpen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_32:
   \   00000000   0x........         DC32     G_au8AntMessageClose

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_33:
   \   00000000   0x........         DC32     G_au8AntMessageAssign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_34:
   \   00000000   0x........         DC32     G_au8AntMessageUnassign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_35:
   \   00000000   0x........         DC32     G_au8AntMessageUnhandled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_36:
   \   00000000   0x........         DC32     G_au8AntMessageFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_37:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageLow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_38:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageMid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_39:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageHigh

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_40:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_41:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_42:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_43:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_44:
   \   00000000   0x........         DC32     ??au8AntFlagAlert

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_45:
   \   00000000   0x........         DC32     ??au8AntFlagMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_46:
   \   00000000   0x........         DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_47:
   \   00000000   0x........         DC32     Ant_u32TxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_48:
   \   00000000   0x........         DC32     Ant_DebugRxMessageCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_49:
   \   00000000   0x........         DC32     Ant_u32RxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_50:
   \   00000000   0x........         DC32     ??au8TxTimeoutMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_51:
   \   00000000   0x........         DC32     Ant_pfnStateMachine

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x41 0x6E          DC8 "AntRx: timeout\012\015"
   \              0x74 0x52    
   \              0x78 0x3A    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x41 0x6E          DC8 "AntRx: message failed\012\015"
   \              0x74 0x52    
   \              0x78 0x3A    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x0A 0x0D          DC8 "\012\015Unexpected ANT message size\012\012\015"
   \              0x55 0x6E    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x41    
   \              0x4E 0x54    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x73    
   \              0x69 0x7A    
   \              0x65 0x0A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x41 0x4E          DC8 "ANT version: "
   \              0x54 0x20    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x41 0x6E          DC8 "AntTx: msg already in progress\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x6D    
   \              0x73 0x67    
   \              0x20 0x61    
   \              0x6C 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x6F 0x67    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x0A 0x0D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x41 0x6E          DC8 "AntTx: SEN timeout\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x53    
   \              0x45 0x4E    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x41 0x6E          DC8 "AntTx: No token\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x74 0x6F    
   \              0x6B 0x65    
   \              0x6E 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x41 0x6E          DC8 "AntTx: No SYNC\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x53 0x59    
   \              0x4E 0x43    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x0D 0x0A          DC8 "\015\012ANT expected msg fail\012\015"
   \              0x41 0x4E    
   \              0x54 0x20    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x6D    
   \              0x73 0x67    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x0A    
   \              0x0D 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x0A 0x0D          DC8 "\012\015No space in AntQueueOutgoingMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x4F 0x75    
   \              0x74 0x67    
   \              0x6F 0x69    
   \              0x6E 0x67    
   \              0x4D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x53 0x63          DC8 "Scanning "
   \              0x61 0x6E    
   \              0x6E 0x69    
   \              0x6E 0x67    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x43 0x68          DC8 "Channel closed\012\015"
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x63 0x6C    
   \              0x6F 0x73    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x3A 0x20          DC8 ": unexpected channel event\012\015"
   \              0x75 0x6E    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x63    
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x0A 0x0D          DC8 "\012\015No space in AntQueueApplicationMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x41 0x70    
   \              0x70 0x6C    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x4D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002B   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AdvanceAntRxBufferCurrentChar
       0   AdvanceAntRxBufferUnreadMsgPointer
       0   AntAbortMessage
       4   AntCalculateTxChecksum
       8   AntDeQueueApplicationMessage
         8   -> free
       8   AntDeQueueOutgoingMessage
         8   -> free
      56   AntExpectResponse
        56   -> AntDeQueueOutgoingMessage
        56   -> AntProcessMessage
        56   -> AntRxMessage
        56   -> DebugPrintf
        56   -> IsTimeUp
        56   -> __aeabi_memcpy
      16   AntInitialize
        16   -> AntSyncSerialInitialize
        16   -> DebugLineFeed
        16   -> DebugPrintf
        16   -> SspRequest
      48   AntParseExtendedData
        48   -> DebugPrintf
      48   AntProcessMessage
        48   -> AdvanceAntRxBufferUnreadMsgPointer
        48   -> AntParseExtendedData
        48   -> AntQueueExtendedApplicationMessage
        48   -> AntTickExtended
        48   -> DebugPrintNumber
        48   -> DebugPrintf
        48   -> HexToASCIICharLower
      72   AntQueueExtendedApplicationMessage
        72   -> DebugPrintf
        72   -> __aeabi_memcpy
        72   -> malloc
      64   AntQueueOutgoingMessage
        64   -> DebugPrintf
        64   -> __aeabi_memcpy4
        64   -> malloc
       8   AntRunActiveState
         8   -- Indirect call
       8   AntRxFlowControlCallback
         8   -> AntSrdyPulse
      64   AntRxMessage
        64   -> AdvanceAntRxBufferCurrentChar
        64   -> AdvanceAntRxBufferUnreadMsgPointer
        64   -> AntAbortMessage
        64   -> AntSrdyPulse
        64   -> DebugPrintf
        64   -> __aeabi_memcpy
        64   -> __aeabi_memcpy4
      16   AntSM_Idle
        16   -> AntProcessMessage
        16   -> AntTxMessage
        16   -> DebugPrintf
       0   AntSM_NoResponse
       8   AntSM_ReceiveMessage
         8   -> AntRxMessage
       8   AntSM_TransmitMessage
         8   -> AntDeQueueOutgoingMessage
         8   -> AntSrdyPulse
         8   -> DebugPrintf
         8   -> QueryMessageStatus
       0   AntSrdyPulse
      16   AntSyncSerialInitialize
        16   -> AntCalculateTxChecksum
        16   -> AntExpectResponse
        16   -> AntProcessMessage
        16   -> AntRxMessage
        16   -> AntTxMessage
        16   -> IsTimeUp
      24   AntTickExtended
        24   -> AntQueueExtendedApplicationMessage
       8   AntTxFlowControlCallback
         8   -> AntSrdyPulse
     120   AntTxMessage
       120   -> AdvanceAntRxBufferCurrentChar
       120   -> AdvanceAntRxBufferUnreadMsgPointer
       120   -> AntSrdyPulse
       120   -> DebugPrintf
       120   -> SspWriteData
       120   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_16
       4  ??DataTable21_17
       4  ??DataTable21_18
       4  ??DataTable21_19
       4  ??DataTable21_2
       4  ??DataTable21_20
       4  ??DataTable21_21
       4  ??DataTable21_22
       4  ??DataTable21_23
       4  ??DataTable21_24
       4  ??DataTable21_25
       4  ??DataTable21_26
       4  ??DataTable21_27
       4  ??DataTable21_28
       4  ??DataTable21_29
       4  ??DataTable21_3
       4  ??DataTable21_30
       4  ??DataTable21_31
       4  ??DataTable21_32
       4  ??DataTable21_33
       4  ??DataTable21_34
       4  ??DataTable21_35
       4  ??DataTable21_36
       4  ??DataTable21_37
       4  ??DataTable21_38
       4  ??DataTable21_39
       4  ??DataTable21_4
       4  ??DataTable21_40
       4  ??DataTable21_41
       4  ??DataTable21_42
       4  ??DataTable21_43
       4  ??DataTable21_44
       4  ??DataTable21_45
       4  ??DataTable21_46
       4  ??DataTable21_47
       4  ??DataTable21_48
       4  ??DataTable21_49
       4  ??DataTable21_5
       4  ??DataTable21_50
       4  ??DataTable21_51
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
      20  ?_0
      24  ?_1
      12  ?_10
      20  ?_11
      32  ?_12
      44  ?_13
      36  ?_2
      16  ?_3
      36  ?_4
      24  ?_5
      20  ?_6
      20  ?_7
      28  ?_8
      40  ?_9
      40  AdvanceAntRxBufferCurrentChar
      40  AdvanceAntRxBufferUnreadMsgPointer
      44  AntAbortMessage
      36  AntCalculateTxChecksum
      56  AntDeQueueApplicationMessage
      34  AntDeQueueOutgoingMessage
     214  AntExpectResponse
     554  AntInitialize
     314  AntParseExtendedData
     986  AntProcessMessage
     198  AntQueueExtendedApplicationMessage
     198  AntQueueOutgoingMessage
      12  AntRunActiveState
      58  AntRxFlowControlCallback
     580  AntRxMessage
     140  AntSM_Idle
       2  AntSM_NoResponse
      24  AntSM_ReceiveMessage
     118  AntSM_TransmitMessage
      42  AntSrdyPulse
     212  AntSyncSerialInitialize
     110  AntTickExtended
      22  AntTxFlowControlCallback
     368  AntTxMessage
       4  Ant_DebugProcessRxMessages
       4  Ant_DebugQueuedDataMessages
       4  Ant_DebugRxMessageCounter
       4  Ant_DebugTotalRxMessages
       4  Ant_Ssp
     256  Ant_au8AntRxBuffer
       4  Ant_pfnStateMachine
       4  Ant_psDataOutgoingMsgList
       4  Ant_pu8AntRxBufferCurrentChar
       4  Ant_pu8AntRxBufferNextChar
       4  Ant_pu8AntRxBufferUnreadMsg
      36  Ant_sSspConfig
       4  Ant_u32ApplicationMessageCount
       4  Ant_u32CurrentTxMessageToken
       4  Ant_u32OutgoingMessageCount
       4  Ant_u32RxByteCounter
       4  Ant_u32RxTimeoutCounter
       4  Ant_u32RxTimer
       4  Ant_u32TxByteCounter
       4  Ant_u32TxTimer
       4  Ant_u32UnexpectedByteCounter
       1  Ant_u8AntNewRxMessages
      12  Ant_u8AntVersion
       1  Ant_u8SlaveMissedMessageHigh
       1  Ant_u8SlaveMissedMessageLow
       1  Ant_u8SlaveMissedMessageMid
     160  G_asAntChannelConfiguration
       8  G_au8ANTGetVersion
      12  G_au8AntAckDataMessage
       8  G_au8AntAssignChannel
      12  G_au8AntBroadcastDataMessage
       8  G_au8AntLibConfig
      24  G_au8AntMessageAssign
      24  G_au8AntMessageClose
       8  G_au8AntMessageFail
      24  G_au8AntMessageInit
      32  G_au8AntMessageInitFail
      64  G_au8AntMessageNoAnt
       8  G_au8AntMessageOk
      20  G_au8AntMessageOpen
      24  G_au8AntMessageSetup
      24  G_au8AntMessageUnassign
      40  G_au8AntMessageUnhandled
       8  G_au8AntSetChannelID
       8  G_au8AntSetChannelPeriod
       8  G_au8AntSetChannelPower
       8  G_au8AntSetChannelRFFreq
      12  G_au8AntSetNetworkKey
       4  G_sAntApplicationMsgList
       4  G_stMessageResponse
       4  G_u32AntFlags
      16  au8AntFlagAlert
      80  au8AntFlagMessages
      32  au8TxTimeoutMsg

 
   556 bytes in section .bss
   512 bytes in section .data
   372 bytes in section .rodata
 4 734 bytes in section .text
 
 4 734 bytes of CODE  memory
   372 bytes of CONST memory
 1 068 bytes of DATA  memory

Errors: none
Warnings: 3
