###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        01/Nov/2018  14:43:52
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpg_common\drivers\ant_api.c
#    Command line =  
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpg_common\drivers\ant_api.c" -D MPGL1 -D MPG1 -D
#        EIE1 --preprocess=cl
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\Debug\List\" -lC
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\Debug\List\" -o
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\Debug\Obj\" --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        D:\EiE\arm\INC\c\DLib_Config_Normal.h -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\" -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\bsp\" -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\drivers\" -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\application\" -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\" -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\"
#        -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\"
#        -I
#        "C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\"
#        -On --use_c++_inline --require_prototypes -I D:\EiE\arm\CMSIS\Include\
#    List file    =  
#        C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\Debug\List\ant_api.lst
#    Object file  =  
#        C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding
#        TestMessage\firmware_mpgl1\iar_7_20_1\Debug\Obj\ant_api.o
#
###############################################################################

C:\Users\10428\Desktop\HOMEWORK-ANTMaster-master\HOMEWORK-ANTMaster--\sennding TestMessage\firmware_mpg_common\drivers\ant_api.c
      1          /***********************************************************************************************************************
                                                                                                                                        ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2          File: ant_api.c                                                               
      3          
      4          Description:
      5          ANT user interface.  No initialization or state machine required.  This file exposes the source code
      6          for all public functions that work with ant.c.  Seperating it keep sit a little more manageable.
      7          
      8          Once the ANT radio has been configured, all messaging from the ANT device is handled through 
      9          the incoming queue G_sAntApplicationMsgList.  The application is responsible for checking this
     10          queue for messages that belong to it and must manage timing and handle appropriate updates per 
     11          the ANT messaging protocol.  This should be no problem on the regular 1ms loop timing of the main 
     12          system (assuming ANT message rate is less than 1kHz).  Faster systems or burst messaging will need 
     13          to be handled seperately as an add-on to this API.
     14          
     15          
     16          ------------------------------------------------------------------------------------------------------------------------
     17          API:
     18          
     19          GLOBALS
     20          Three global variables give access to the latest ANT message data.
     21          Copy the following definitions to your client task:
     22          
     23          // Globals for passing data from the ANT application to the API 
     24          extern u32 G_u32AntApiCurrentMessageTimeStamp;                            // From ant_api.c
     25          extern AntApplicationMessageType G_eAntApiCurrentMessageClass;            // From ant_api.c
     26          extern u8 G_au8AntApiCurrentMessageBytes[ANT_APPLICATION_MESSAGE_BYTES];  // From ant_api.c
     27          extern AntExtendedDataType G_sAntApiCurrentMessageExtData;                // From ant_api.c
     28          
     29          TYPES
     30          Defined in ant.h but used throughout ant_api.c
     31          
     32          AntChannelNumberType (allowed to be indexed and type cast to sequentially access channels)
     33          {ANT_CHANNEL_0 = 0, ANT_CHANNEL_1, ANT_CHANNEL_2, ANT_CHANNEL_3,
     34          ANT_CHANNEL_4, ANT_CHANNEL_5, ANT_CHANNEL_6, ANT_CHANNEL_7,
     35          ANT_CHANNEL_SCANNING = 0}
     36          
     37          AntChannelStatusType
     38          {ANT_UNCONFIGURED, ANT_CONFIGURED, ANT_OPENING, ANT_OPEN, ANT_CLOSING, ANT_CLOSED}
     39          
     40          AntApplicationMessageType
     41          {ANT_EMPTY, ANT_DATA, ANT_TICK}
     42          
     43          AntApplicationGenericMsgStatus
     44          {ANT_GENERIC_MSG_READY, ANT_GENERIC_MSG_BUSY, ANT_GENERIC_MSG_OK, ANT_GENERIC_MSG_FAIL}
     45          
     46          Structs
     47          AntExtendedDataType
     48          AntApplicationMsgListType
     49          AntAssignChannelInfoType
     50          
     51          *** ANT CONFIGURATION / STATUS FUNCTIONS ***
     52          
     53          AntChannelStatusType AntRadioStatusChannel(AntChannelNumberType eChannel_)
     54          Query the status of the specified channel.  
     55          Returns ANT_UNCONFIGURED, ANT_CONFIGURED, ANT_OPENING, ANT_OPEN, ANT_CLOSING, ANT_CLOSED
     56          ANT_CONFIGURED and ANT_CLOSED are actually the same state.
     57          e.g.
     58          AntChannelStatus eAntCurrentStatus;
     59          
     60          // Get the status of Channel 1
     61          eAntCurrentStatus = AntRadioStatusChannel(ANT_CHANNEL_1);
     62          
     63          
     64          bool AntAssignChannel(AntAssignChannelInfoType* psAntSetupInfo_)
     65          Updates all configuration messages to completely configure an ANT channel with an application's 
     66          required parameters for communication.  The application should monitor AntRadioStatusChannel()
     67          to see if all of the configuration messages are sent and the channel is configured properly.
     68          e.g.
     69          AntAssignChannelInfoType sChannelInfo;
     70          
     71          if(AntRadioStatusChannel(ANT_CHANNEL_0) == ANT_UNCONFIGURED)
     72          {
     73            sChannelInfo.AntChannel = ANT_CHANNEL_0;
     74            sChannelInfo.AntChannelType = CHANNEL_TYPE_MASTER;
     75            sChannelInfo.AntChannelPeriodHi = ANT_CHANNEL_PERIOD_HI_DEFAULT;
     76            sChannelInfo.AntChannelPeriodLo = ANT_CHANNEL_PERIOD_LO_DEFAULT;
     77            
     78            sChannelInfo.AntDeviceIdHi = 0x00;
     79            sChannelInfo.AntDeviceIdLo = 0x01;
     80            sChannelInfo.AntDeviceType = ANT_DEVICE_TYPE_DEFAULT;
     81            sChannelInfo.AntTransmissionType = ANT_TRANSMISSION_TYPE_DEFAULT;
     82            
     83            sChannelInfo.AntFrequency = ANT_FREQUENCY_DEFAULT;
     84            sChannelInfo.AntTxPower = ANT_TX_POWER_DEFAULT;
     85            
     86            sChannelInfo.AntNetwork = ANT_NETWORK_DEFAULT;
     87            for(u8 i = 0; i < ANT_NETWORK_NUMBER_BYTES; i++)
     88            {
     89              sChannelInfo.AntNetworkKey[i] = ANT_DEFAULT_NETWORK_KEY;
     90            }
     91            
     92            AntAssignChannel(&sChannelInfo);
     93          }
     94          
     95            // Go to a wait state that exits when AntRadioStatusChannel(ANT_CHANNEL_0) no longer returns ANT_UNCONFIGURED)
     96          
     97          
     98          bool AntUnassignChannelNumber(AntChannelNumberType eChannel_)
     99          Queues message to unassign the specified ANT channel so it can be reconfigured.
    100          e.g.
    101          AntUnassignChannelNumber(ANT_CHANNEL_1)
    102          // Go to wait state that exists when AntRadioStatusChannel(ANT_CHANNEL_1) returns ANT_UNCONFIGURED
    103          
    104          
    105          bool AntOpenChannelNumber(AntChannelNumberType eAntChannelToOpen)
    106          Queues a request to open the specified channel.
    107          Returns TRUE if the channel is configured and the message is successfully queued - this can be ignored or checked.  
    108          Application should monitor AntRadioStatusChannel() for actual channel status.
    109          e.g.
    110          AntChannelStatusType eAntCurrentState;
    111          
    112          // Request to open channel only on an already closed channel.
    113          eAntCurrentState = AntChannelStatus(ANT_CHANNEL_1);
    114          
    115          if(eAntCurrentState == ANT_CLOSED )
    116          {
    117             AntOpenChannelNumber(ANT_CHANNEL_1);
    118          }
    119          
    120          
    121          bool AntCloseChannelNumber(AntChannelNumberType eAntChannelToOpen)
    122          Queues a request to close the specified channel.
    123          Returns TRUE if the message is successfully queued - this can be ignored or checked.  
    124          Application should monitor AntRadioStatusChannel() for actual channel status.
    125          e.g.
    126          AntChannelStatusType eAntCurrentState;
    127          
    128          // Request to close channel only on an open channel.
    129          if(AntRadioStatusChannel(ANT_CHANNEL_1) == ANT_OPEN )
    130          {
    131             AntCloseChannelNumber(ANT_CHANNEL_1);
    132          }
    133          
    134          bool AntOpenScanningChannel(void)
    135          Queues a request to open a scanning channel. Channel 0 setup parameters are used,
    136          but note that all channel resources are used by a scanning channel.  Trying to
    137          open a scanning channel if any other channel is open will fail.
    138          
    139          Returns TRUE if message is successfully queued - this can be ignored or checked.  
    140          Application should monitor AntRadioStatusChannel() for actual channel status.
    141          e.g.
    142          AntChannelStatusType eAntCurrentState;
    143          
    144          // Request to open channel only on an already closed channel.
    145          if(AntRadioStatusChannel(ANT_CHANNEL_SCANNING) == ANT_CLOSED )
    146          {
    147             AntOpenScanningChannel();
    148          }
    149          
    150          
    151          bool AntSendGenericMessage()
    152          Queues a generic message to be sent to ANT.  Any of the ANT message codes can be sent.
    153          The entire message string except the checksum must be provided.
    154          Returns TRUE if a message can be sent to ANT.
    155          Returns FALSE if the system is not available to send to ANT (i.e. a message is currently being sent)
    156          Application must then monitor AntCheckGenericMessageStatus() to determine when 
    157          
    158          e.g.
    159          AntChannelStatusType eAntCurrentState;
    160          
    161          
    162          ***ANT DATA FUNCTIONS***
    163          bool AntQueueBroadcastMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    164          Queue a broadcast data message.
    165          e.g.
    166          u8 u8DataToSend[ANT_DATA_BYTES] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    167          AntQueueBroadcastMessage(ANT_CHANNEL_1, &u8DataToSend[0]);
    168          
    169          
    170          bool AntQueueAcknowledgedMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    171          Queue an acknowledged data message.
    172          e.g.
    173          u8 u8DataToSend[ANT_DATA_BYTES] = {0x07, 0x06, 0x05, 0x04, 0x03, 0xdd, 0xee, 0xff};
    174          AntQueueAcknowledgedMessage(ANT_CHANNEL_1, u8DataToSend);
    175          
    176          
    177          bool AntReadAppMessageBuffer(void)
    178          Check the incoming message buffer for any message from the ANT system (either ANT_TICK or ANT_DATA).  
    179          If no messages are present, returns FALSE.  If a message is there, returns TRUE and application can read:
    180          - G_u32AntApiCurrentMessageTimeStamp to see the system time stamp when the message arrived
    181          - G_eAntApiCurrentMessageClass to see what kind of message is present
    182          - G_au8AntApiCurrentMessageBytes[ANT_APPLICATION_MESSAGE_BYTES] to see the message bytes.
    183          - G_sAntApiCurrentMessageExtData to see an available extended data (on incoming messages)
    184          
    185          e.g.
    186          u32 u32CurrentMessageTimeStamp;
    187          u8 u8CurrentTickEventCode;
    188          u8 u8CurrentMessageContents[ANT_APPLICATION_MESSAGE_BYTES];
    189          
    190          if(AntReadAppMessageBuffer())
    191          {
    192            // Report the time a message was received
    193            DebugPrintNumber(u32CurrentMessageTimeStamp);
    194            DebugPrintf(": message received\n\t");
    195          
    196            // Check the message class to determine how to process the message
    197            if(G_eAntApiCurrentMessageClass == ANT_TICK)
    198            {
    199              // Get the EVENT code from the ANT_TICK message 
    200              u8CurrentTickEventCode = G_au8AntApiCurrentMessageBytes[ANT_TICK_MSG_EVENT_CODE_INDEX];
    201            }
    202          
    203            if(G_eAntApiCurrentMessageClass == ANT_DATA)
    204            {
    205              // Copy the message data locally
    206              for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
    207              {
    208                u8CurrentMessageContents[i] = G_au8AntApiCurrentMessageBytes[i];
    209              }
    210            }
    211          }
    212          
    213          
    214          ***********************************************************************************************************************/
    215          
    216          #include "configuration.h"
    217          
    218          
    219          /***********************************************************************************************************************
    220          Global variable definitions with scope across entire project.
    221          All Global variable names shall start with "G_<type>AntApi"
    222          ***********************************************************************************************************************/
    223          

   \                                 In section .bss, align 4
    224          volatile u32 G_u32AntApiFlags;                                          /* Global state flags */
   \                     G_u32AntApiFlags:
   \   00000000                      DS8 4
    225          

   \                                 In section .bss, align 4
    226          u32 G_u32AntApiCurrentMessageTimeStamp = 0;                             /* Current read message's G_u32SystemTime1ms */
   \                     G_u32AntApiCurrentMessageTimeStamp:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    227          AntApplicationMessageType G_eAntApiCurrentMessageClass = ANT_EMPTY;     /* Type of data */
   \                     G_eAntApiCurrentMessageClass:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    228          u8 G_au8AntApiCurrentMessageBytes[ANT_APPLICATION_MESSAGE_BYTES];       /* Array for message payload data */
   \                     G_au8AntApiCurrentMessageBytes:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    229          AntExtendedDataType G_sAntApiCurrentMessageExtData;                     /* Extended data struct for the current message */
   \                     G_sAntApiCurrentMessageExtData:
   \   00000000                      DS8 8
    230          
    231          /*----------------------------------------------------------------------------*/
    232          /* Existing variables (defined in other files -- should all contain the "extern" keyword) 
    233          and indicate what file the variable is defined in. */
    234          extern u32 G_u32SystemFlags;                                  /* From main.c */
    235          extern u32 G_u32ApplicationFlags;                             /* From main.c */
    236          
    237          extern volatile u32 G_u32SystemTime1ms;                       /* From board-specific source file */
    238          extern volatile u32 G_u32SystemTime1s;                        /* From board-specific source file */
    239          
    240          extern u32 G_u32AntFlags;                                     /* From ant.c */
    241          extern AntApplicationMsgListType *G_sAntApplicationMsgList;   /* From ant.c */
    242          extern AntAssignChannelInfoType G_asAntChannelConfiguration[ANT_NUM_CHANNELS]; /* From ant.c */
    243          extern AntMessageResponseType G_stMessageResponse;            /* From ant.c */
    244          
    245          extern u8 G_au8AntMessageOk[];                                /* From ant.c */
    246          extern u8 G_au8AntMessageFail[];                              /* From ant.c */
    247          extern u8 G_au8AntMessageAssign[];                            /* From ant.c */
    248          extern u8 G_au8AntMessageUnassign[];                          /* From ant.c */
    249          extern u8 G_au8AntMessageUnhandled[];                         /* From ant.c */
    250          extern u8 G_au8AntMessageSetup[];                             /* From ant.c */
    251          extern u8 G_au8AntMessageClose[];                             /* From ant.c */
    252          extern u8 G_au8AntMessageOpen[];                              /* From ant.c */
    253          extern u8 G_au8AntMessageInit[];                              /* From ant.c */
    254          extern u8 G_au8AntMessageInitFail[];                          /* From ant.c */
    255          extern u8 G_au8AntMessageNoAnt[];                             /* From ant.c */
    256          
    257          extern u8 G_au8AntSetNetworkKey[];                            /* From ant.c */
    258          extern u8 G_au8AntAssignChannel[];                            /* From ant.c */
    259          extern u8 G_au8AntSetChannelID[];                             /* From ant.c */
    260          extern u8 G_au8AntSetChannelPeriod[];                         /* From ant.c */
    261          extern u8 G_au8AntSetChannelRFFreq[];                         /* From ant.c */
    262          extern u8 G_au8AntSetChannelPower[];                          /* From ant.c */
    263          extern u8 G_au8AntLibConfig[];                                /* From ant.c */
    264          
    265          extern u8 G_au8AntBroadcastDataMessage[];                     /* From ant.c */
    266          extern u8 G_au8AntAckDataMessage[];                           /* From ant.c */
    267          
    268          
    269          /***********************************************************************************************************************
    270          Global variable definitions with scope limited to this local application.
    271          Variable names shall start with "AntApi_<type>Name" and be declared as static.
    272          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
    273          static fnCode_type AntApi_StateMachine;             /* The state machine function pointer */
   \                     AntApi_StateMachine:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    274          static u32 AntApi_u32Timeout;                       /* Timeout counter used across states */
   \                     AntApi_u32Timeout:
   \   00000000                      DS8 4
    275          
    276          /* Message for channel assignment.  Set ANT_ASSIGN_MESSAGES for number of messages. */

   \                                 In section .data, align 4
    277          static u8* AntApi_apu8AntAssignChannel[] = {G_au8AntSetNetworkKey, G_au8AntLibConfig, G_au8AntAssignChannel, G_au8AntSetChannelID, 
   \                     AntApi_apu8AntAssignChannel:
   \   00000000   0x........         DC32 G_au8AntSetNetworkKey, G_au8AntLibConfig, G_au8AntAssignChannel
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 G_au8AntSetChannelID, G_au8AntSetChannelPeriod
   \              0x........   
   \   00000014   0x........         DC32 G_au8AntSetChannelRFFreq, G_au8AntSetChannelPower
   \              0x........   
    278                                                      G_au8AntSetChannelPeriod, G_au8AntSetChannelRFFreq, G_au8AntSetChannelPower 
    279                                                     }; 
    280          
    281          /***********************************************************************************************************************
    282          Function Definitions
    283          ***********************************************************************************************************************/
    284          
    285          /*--------------------------------------------------------------------------------------------------------------------*/
    286          /* Public functions                                                                                                   */
    287          /*--------------------------------------------------------------------------------------------------------------------*/
    288          
    289          /*------------------------------------------------------------------------------
    290          Function: AntAssignChannel
    291          Description:
    292          Updates all configuration messages to completely configure an ANT channel with an application's 
    293          required parameters for communication.  The ANT API state machine then sends and monitors the commands
    294          to ensure the requested channel is setup properly.  The application should monitor AntRadioStatusChannel()
    295          to see if the channel is configured properly.
    296          
    297          Requires:
    298            - psAntSetupInfo_ points to a complete AntAssignChannelInfoType with all the required channel information.
    299            - The ANT channel should not be currently assigned.
    300          
    301          Promises:
    302            - Channel, Channel ID, message period, radio frequency and radio power are configured.
    303            - Returns TRUE if the channel is ready to be set up; all global setup messages are updated with the values
    304              from psAntSetupInfo; 
    305            - Returns FALSE if the channel is already configured
    306          */

   \                                 In section .text, align 2, keep-with-next
    307          bool AntAssignChannel(AntAssignChannelInfoType* psAntSetupInfo_)
    308          {
   \                     AntAssignChannel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    309          
    310            /* Check to ensure the selected channel is available */
    311            if(AntRadioStatusChannel(psAntSetupInfo_->AntChannel) != ANT_UNCONFIGURED)
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       AntRadioStatusChannel
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD005             BEQ.N    ??AntAssignChannel_0
    312            {
    313              DebugPrintf("AntAssignChannel error: channel is not unconfigured\n\r");
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000012   0x.... 0x....      BL       DebugPrintf
    314              return FALSE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE0E6             B.N      ??AntAssignChannel_1
    315            }
    316            
    317            /* Setup the library config message (for extended data) - use defaults for now */
    318            G_au8AntLibConfig[4] = AntCalculateTxChecksum(G_au8AntLibConfig);
   \                     ??AntAssignChannel_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   0000001E   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   00000026   0x7108             STRB     R0,[R1, #+4]
    319          
    320            /* Set Network key message */
    321            G_au8AntSetNetworkKey[2] = psAntSetupInfo_->AntNetwork;
   \   00000028   0x78A0             LDRB     R0,[R4, #+2]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   0000002E   0x7088             STRB     R0,[R1, #+2]
    322            for(u8 i = 0; i < ANT_NETWORK_NUMBER_BYTES; i++)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??AntAssignChannel_2: (+1)
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xDA15             BGE.N    ??AntAssignChannel_3
    323            {
    324              G_au8AntSetNetworkKey[i + 3] = psAntSetupInfo_->AntNetworkKey[i];
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x1901             ADDS     R1,R0,R4
   \   0000003C   0x78C9             LDRB     R1,[R1, #+3]
   \   0000003E   0x.... 0x....      LDR.W    R2,??DataTable11_2
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x1882             ADDS     R2,R0,R2
   \   00000046   0x70D1             STRB     R1,[R2, #+3]
    325              G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntNetworkKey[i] = psAntSetupInfo_->AntNetworkKey[i];
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000004C   0x7822             LDRB     R2,[R4, #+0]
   \   0000004E   0x2314             MOVS     R3,#+20
   \   00000050   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x1841             ADDS     R1,R0,R1
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x1902             ADDS     R2,R0,R4
   \   0000005C   0x78D2             LDRB     R2,[R2, #+3]
   \   0000005E   0x70CA             STRB     R2,[R1, #+3]
    326            }
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0xE7E6             B.N      ??AntAssignChannel_2
    327            G_au8AntSetNetworkKey[11] = AntCalculateTxChecksum(G_au8AntSetNetworkKey);
   \                     ??AntAssignChannel_3: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000068   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000070   0x72C8             STRB     R0,[R1, #+11]
    328              
    329            /* Setup the channel message */
    330            G_au8AntAssignChannel[2] = psAntSetupInfo_->AntChannel;
   \   00000072   0x7820             LDRB     R0,[R4, #+0]
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   00000078   0x7088             STRB     R0,[R1, #+2]
    331            G_au8AntAssignChannel[3] = psAntSetupInfo_->AntChannelType;
   \   0000007A   0x7860             LDRB     R0,[R4, #+1]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   00000080   0x70C8             STRB     R0,[R1, #+3]
    332            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntChannelType = psAntSetupInfo_->AntChannelType;
   \   00000082   0x7860             LDRB     R0,[R4, #+1]
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000088   0x7822             LDRB     R2,[R4, #+0]
   \   0000008A   0x2314             MOVS     R3,#+20
   \   0000008C   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000090   0x7048             STRB     R0,[R1, #+1]
    333          
    334            G_au8AntAssignChannel[4] = psAntSetupInfo_->AntNetwork;
   \   00000092   0x78A0             LDRB     R0,[R4, #+2]
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   00000098   0x7108             STRB     R0,[R1, #+4]
    335            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntNetwork = psAntSetupInfo_->AntNetwork;
   \   0000009A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000A0   0x7822             LDRB     R2,[R4, #+0]
   \   000000A2   0x2314             MOVS     R3,#+20
   \   000000A4   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000000A8   0x7088             STRB     R0,[R1, #+2]
    336          
    337            G_au8AntAssignChannel[5] = AntCalculateTxChecksum(G_au8AntAssignChannel);
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \   000000AE   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   000000B6   0x7148             STRB     R0,[R1, #+5]
    338          
    339            /* Setup the channel ID message */
    340            G_au8AntSetChannelID[2] = psAntSetupInfo_->AntChannel;
   \   000000B8   0x7820             LDRB     R0,[R4, #+0]
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000BE   0x7088             STRB     R0,[R1, #+2]
    341            G_au8AntSetChannelID[3] = psAntSetupInfo_->AntDeviceIdLo;
   \   000000C0   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000C6   0x70C8             STRB     R0,[R1, #+3]
    342            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntDeviceIdLo = psAntSetupInfo_->AntDeviceIdLo;
   \   000000C8   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000CE   0x7822             LDRB     R2,[R4, #+0]
   \   000000D0   0x2314             MOVS     R3,#+20
   \   000000D2   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000000D6   0x72C8             STRB     R0,[R1, #+11]
    343          
    344            G_au8AntSetChannelID[4] = psAntSetupInfo_->AntDeviceIdHi;
   \   000000D8   0x7B20             LDRB     R0,[R4, #+12]
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000DE   0x7108             STRB     R0,[R1, #+4]
    345            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntDeviceIdHi = psAntSetupInfo_->AntDeviceIdHi;
   \   000000E0   0x7B20             LDRB     R0,[R4, #+12]
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000E6   0x7822             LDRB     R2,[R4, #+0]
   \   000000E8   0x2314             MOVS     R3,#+20
   \   000000EA   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000000EE   0x7308             STRB     R0,[R1, #+12]
    346          
    347            G_au8AntSetChannelID[5] = psAntSetupInfo_->AntDeviceType;
   \   000000F0   0x7B60             LDRB     R0,[R4, #+13]
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000F6   0x7148             STRB     R0,[R1, #+5]
    348            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntDeviceType = psAntSetupInfo_->AntDeviceType;
   \   000000F8   0x7B60             LDRB     R0,[R4, #+13]
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000FE   0x7822             LDRB     R2,[R4, #+0]
   \   00000100   0x2314             MOVS     R3,#+20
   \   00000102   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000106   0x7348             STRB     R0,[R1, #+13]
    349          
    350            G_au8AntSetChannelID[6] = psAntSetupInfo_->AntTransmissionType;
   \   00000108   0x7BA0             LDRB     R0,[R4, #+14]
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   0000010E   0x7188             STRB     R0,[R1, #+6]
    351            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntTransmissionType = psAntSetupInfo_->AntTransmissionType;
   \   00000110   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000116   0x7822             LDRB     R2,[R4, #+0]
   \   00000118   0x2314             MOVS     R3,#+20
   \   0000011A   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000011E   0x7388             STRB     R0,[R1, #+14]
    352          
    353            G_au8AntSetChannelID[7] = AntCalculateTxChecksum(G_au8AntSetChannelID);
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000124   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   0000012C   0x71C8             STRB     R0,[R1, #+7]
    354              
    355            /* Setup the channel period message */
    356            G_au8AntSetChannelPeriod[2] = psAntSetupInfo_->AntChannel;
   \   0000012E   0x7820             LDRB     R0,[R4, #+0]
   \   00000130   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   00000134   0x7088             STRB     R0,[R1, #+2]
    357            G_au8AntSetChannelPeriod[3] = psAntSetupInfo_->AntChannelPeriodLo;
   \   00000136   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   0000013C   0x70C8             STRB     R0,[R1, #+3]
    358            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntChannelPeriodLo = psAntSetupInfo_->AntChannelPeriodLo;
   \   0000013E   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000144   0x7822             LDRB     R2,[R4, #+0]
   \   00000146   0x2314             MOVS     R3,#+20
   \   00000148   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000014C   0x73C8             STRB     R0,[R1, #+15]
    359          
    360            G_au8AntSetChannelPeriod[4] = psAntSetupInfo_->AntChannelPeriodHi;
   \   0000014E   0x7C20             LDRB     R0,[R4, #+16]
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   00000154   0x7108             STRB     R0,[R1, #+4]
    361            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntChannelPeriodHi = psAntSetupInfo_->AntChannelPeriodHi;
   \   00000156   0x7C20             LDRB     R0,[R4, #+16]
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000015C   0x7822             LDRB     R2,[R4, #+0]
   \   0000015E   0x2314             MOVS     R3,#+20
   \   00000160   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000164   0x7408             STRB     R0,[R1, #+16]
    362          
    363            G_au8AntSetChannelPeriod[5] = AntCalculateTxChecksum(G_au8AntSetChannelPeriod);
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable11_6
   \   0000016A   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000016E   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   00000172   0x7148             STRB     R0,[R1, #+5]
    364              
    365            /* Setup the channel frequency message */
    366            G_au8AntSetChannelRFFreq[2] = psAntSetupInfo_->AntChannel;
   \   00000174   0x7820             LDRB     R0,[R4, #+0]
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable11_7
   \   0000017A   0x7088             STRB     R0,[R1, #+2]
    367            G_au8AntSetChannelRFFreq[3] = psAntSetupInfo_->AntFrequency;
   \   0000017C   0x7C60             LDRB     R0,[R4, #+17]
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable11_7
   \   00000182   0x70C8             STRB     R0,[R1, #+3]
    368            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntFrequency = psAntSetupInfo_->AntFrequency;
   \   00000184   0x7C60             LDRB     R0,[R4, #+17]
   \   00000186   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000018A   0x7822             LDRB     R2,[R4, #+0]
   \   0000018C   0x2314             MOVS     R3,#+20
   \   0000018E   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000192   0x7448             STRB     R0,[R1, #+17]
    369          
    370            G_au8AntSetChannelRFFreq[4] = AntCalculateTxChecksum(G_au8AntSetChannelRFFreq);
   \   00000194   0x.... 0x....      LDR.W    R0,??DataTable11_7
   \   00000198   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000019C   0x.... 0x....      LDR.W    R1,??DataTable11_7
   \   000001A0   0x7108             STRB     R0,[R1, #+4]
    371          
    372            /* Setup the channel power message */
    373            G_au8AntSetChannelPower[2] = psAntSetupInfo_->AntChannel;
   \   000001A2   0x7820             LDRB     R0,[R4, #+0]
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \   000001A8   0x7088             STRB     R0,[R1, #+2]
    374            G_au8AntSetChannelPower[3] = psAntSetupInfo_->AntTxPower;
   \   000001AA   0x7CA0             LDRB     R0,[R4, #+18]
   \   000001AC   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \   000001B0   0x70C8             STRB     R0,[R1, #+3]
    375            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntTxPower = psAntSetupInfo_->AntTxPower;
   \   000001B2   0x7CA0             LDRB     R0,[R4, #+18]
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000001B8   0x7822             LDRB     R2,[R4, #+0]
   \   000001BA   0x2314             MOVS     R3,#+20
   \   000001BC   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000001C0   0x7488             STRB     R0,[R1, #+18]
    376          
    377            G_au8AntSetChannelPower[4] = AntCalculateTxChecksum(G_au8AntSetChannelPower);
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \   000001C6   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000001CA   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \   000001CE   0x7108             STRB     R0,[R1, #+4]
    378               
    379            /* Set the next state to begin transferring */
    380            AntApi_u32Timeout = G_u32SystemTime1ms;
   \   000001D0   0x.... 0x....      LDR.W    R0,??DataTable11_9
   \   000001D4   0x6800             LDR      R0,[R0, #+0]
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable11_10
   \   000001DA   0x6008             STR      R0,[R1, #+0]
    381            AntApi_StateMachine = AntApiSM_AssignChannel;
   \   000001DC   0x.... 0x....      ADR.W    R0,AntApiSM_AssignChannel
   \   000001E0   0x.... 0x....      LDR.W    R1,??DataTable11_11
   \   000001E4   0x6008             STR      R0,[R1, #+0]
    382            return TRUE;
   \   000001E6   0x2001             MOVS     R0,#+1
   \                     ??AntAssignChannel_1: (+1)
   \   000001E8   0xBD10             POP      {R4,PC}          ;; return
    383          
    384          } /* end AntAssignChannel() */
    385          
    386          
    387          /*------------------------------------------------------------------------------
    388          Function: AntUnassignChannelNumber
    389          
    390          Description:
    391          Queues message to unassigns the specified ANT channel so it can be reconfigured.
    392            
    393          Requires:
    394            - ANT channel is closed
    395          
    396          Promises:
    397            - ANT channel unassign message is queued; application should monitor AntRadioStatus()
    398          */

   \                                 In section .text, align 2, keep-with-next
    399          bool AntUnassignChannelNumber(AntChannelNumberType eChannel_)
    400          {
   \                     AntUnassignChannelNumber: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    401            u8 au8AntUnassignChannel[] = {MESG_UNASSIGN_CHANNEL_SIZE, MESG_UNASSIGN_CHANNEL_ID, 0, CS};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable11_12
   \   0000000C   0x680A             LDR      R2,[R1, #0]
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    402          
    403            /* Update the channel number */
    404             au8AntUnassignChannel[2] = eChannel_;
   \   00000010   0xF88D 0x4002      STRB     R4,[SP, #+2]
    405          
    406            /* Update checksum and queue the unassign channel message */
    407            au8AntUnassignChannel[3] = AntCalculateTxChecksum(au8AntUnassignChannel);
   \   00000014   0xA800             ADD      R0,SP,#+0
   \   00000016   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000001A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    408            G_asAntChannelConfiguration[eChannel_].AntFlags &= ~_ANT_FLAGS_CHANNEL_CONFIGURED;
   \   0000001E   0x....             LDR.N    R0,??DataTable11_3
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2114             MOVS     R1,#+20
   \   00000024   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000028   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000002A   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000002E   0x....             LDR.N    R1,??DataTable11_3
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2214             MOVS     R2,#+20
   \   00000034   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000038   0x74C8             STRB     R0,[R1, #+19]
    409            return( AntQueueOutgoingMessage(au8AntUnassignChannel) );
   \   0000003A   0xA800             ADD      R0,SP,#+0
   \   0000003C   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000040   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    410          
    411          } /* end AntUnassignChannelNumber() */
    412          
    413          
    414          /*------------------------------------------------------------------------------
    415          Function: AntOpenChannelNumber
    416          
    417          Description:
    418          Queues the Open Channel message on the configured ANT channel.  This does not actually indicate
    419          that the channel has been opened successfully -- the calling task must monitor _ANT_FLAGS_CHANNEL_OPEN
    420          to determine if channel opens successfully.
    421            
    422          Requires:
    423            - eChannel_ is ANT_CHANNEL_0, ..., ANT_CHANNEL_7, ANT_CHANNEL_SCANNING
    424            - ANT channel to open should be correctly configured.
    425          
    426          Promises:
    427            - If channel open message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    428            - Otherwise returns FALSE
    429           
    430          */

   \                                 In section .text, align 2, keep-with-next
    431          bool AntOpenChannelNumber(AntChannelNumberType eChannel_)
    432          {
   \                     AntOpenChannelNumber: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    433            u8 au8AntOpenChannel[] = {MESG_OPEN_CHANNEL_SIZE, MESG_OPEN_CHANNEL_ID, 0, CS};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable11_13
   \   0000000A   0x680A             LDR      R2,[R1, #0]
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    434            
    435            /* Update the channel number in the message for a regular channel */
    436            if(eChannel_ != ANT_CHANNEL_SCANNING)
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD001             BEQ.N    ??AntOpenChannelNumber_0
    437            {
    438              au8AntOpenChannel[2] = eChannel_;
   \   00000014   0xF88D 0x4002      STRB     R4,[SP, #+2]
    439            }
    440          
    441            /* Update the checksum value and queue the open channel message */
    442            au8AntOpenChannel[3] = AntCalculateTxChecksum(au8AntOpenChannel);
   \                     ??AntOpenChannelNumber_0: (+1)
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000001E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    443            G_asAntChannelConfiguration[eChannel_].AntFlags |= _ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   00000022   0x....             LDR.N    R0,??DataTable11_3
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2114             MOVS     R1,#+20
   \   00000028   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000002C   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000002E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000032   0x....             LDR.N    R1,??DataTable11_3
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2214             MOVS     R2,#+20
   \   00000038   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000003C   0x74C8             STRB     R0,[R1, #+19]
    444           
    445            return( AntQueueOutgoingMessage(au8AntOpenChannel) );
   \   0000003E   0xA800             ADD      R0,SP,#+0
   \   00000040   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000044   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    446            
    447          } /* end AntOpenChannelNumber() */
    448          
    449          
    450          /*------------------------------------------------------------------------------
    451          Function: AntOpenChannelNumber
    452          
    453          Description:
    454          Queues the Open Scan Channel message.  Scanning channels must use Channel 0
    455          and actually take all channel resources.  It is up to the user to ensure
    456          that the device is configured properly.  Attempting to open a scanning channel
    457          when other channels are already open will result in a failure.
    458          
    459          The return value does not actually indicate that the channel has been 
    460          opened successfully -- the calling task must monitor _ANT_FLAGS_CHANNEL_OPEN
    461          to determine if channel opens successfully.
    462            
    463          Requires:
    464            - ANT channel 0 should be correctly configured as a SLAVE.
    465          
    466          Promises:
    467            - If channel open message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    468            - Otherwise returns FALSE
    469           
    470          */

   \                                 In section .text, align 2, keep-with-next
    471          bool AntOpenScanningChannel(void)
    472          {
   \                     AntOpenScanningChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    473            u8 au8AntOpenScanChannel[] = {MESG_OPEN_CHANNEL_SIZE, MESG_OPEN_SCAN_CHANNEL_ID, 0, CS};
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable11_14
   \   00000006   0x680A             LDR      R2,[R1, #0]
   \   00000008   0x6002             STR      R2,[R0, #+0]
    474            
    475            /* Update the checksum value and queue the open channel message */
    476            au8AntOpenScanChannel[3] = AntCalculateTxChecksum(au8AntOpenScanChannel);
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000010   0xF88D 0x0003      STRB     R0,[SP, #+3]
    477            G_asAntChannelConfiguration[0].AntFlags |= _ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   00000014   0x....             LDR.N    R0,??DataTable11_3
   \   00000016   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000018   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000001C   0x....             LDR.N    R1,??DataTable11_3
   \   0000001E   0x74C8             STRB     R0,[R1, #+19]
    478           
    479            return( AntQueueOutgoingMessage(au8AntOpenScanChannel) );
   \   00000020   0xA800             ADD      R0,SP,#+0
   \   00000022   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
    480            
    481          } /* end AntOpenScanningChannelNumber() */
    482          
    483          
    484          
    485          /*------------------------------------------------------------------------------
    486          Function: AntCloseChannelNumber
    487          
    488          Description:
    489          Requests that an ANT channel is closed.  Issuing MESG_CLOSE_CHANNEL_ID does not
    490          guarantee that the channel closes, and ANT response to this message does not
    491          indicate that the channel is closed (a seperate message will be sent when the 
    492          channel actually closes which usually happens on the next ANT message period).
    493            
    494          Requires:
    495            - eChannel_ is ANT_CHANNEL_0, ..., ANT_CHANNEL_7, ANT_CHANNEL_SCANNING
    496            - ANT channel is correctly configured and should be open.
    497          
    498          Promises:
    499            - If channel close message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    500            - Otherwise returns FALSE
    501          */

   \                                 In section .text, align 2, keep-with-next
    502          bool AntCloseChannelNumber(AntChannelNumberType eChannel_)
    503          {
   \                     AntCloseChannelNumber: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    504            u8 au8AntCloseChannel[] = {MESG_CLOSE_CHANNEL_SIZE, MESG_CLOSE_CHANNEL_ID, 0, CS};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable11_15
   \   0000000A   0x680A             LDR      R2,[R1, #0]
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    505            
    506            /* Update the channel number */
    507            au8AntCloseChannel[2] = eChannel_;
   \   0000000E   0xF88D 0x4002      STRB     R4,[SP, #+2]
    508          
    509            /* Update the checksum value and queue the close channel message*/
    510            au8AntCloseChannel[3] = AntCalculateTxChecksum(au8AntCloseChannel);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    511            G_asAntChannelConfiguration[eChannel_].AntFlags |= _ANT_FLAGS_CHANNEL_CLOSE_PENDING;
   \   0000001C   0x....             LDR.N    R0,??DataTable11_3
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2114             MOVS     R1,#+20
   \   00000022   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000026   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000028   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000002C   0x....             LDR.N    R1,??DataTable11_3
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2214             MOVS     R2,#+20
   \   00000032   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000036   0x74C8             STRB     R0,[R1, #+19]
    512            
    513            return( AntQueueOutgoingMessage(au8AntCloseChannel) );
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   0000003E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    514          
    515          } /* end AntCloseChannelNumber() */
    516          
    517          
    518          
    519          
    520          /*------------------------------------------------------------------------------
    521          Function: AntRadioStatusChannel
    522          
    523          Description:
    524          Returns the current radio status of the specified channel to the application.
    525            
    526          Requires:
    527            - G_u32AntFlags are up to date
    528          
    529          Promises:
    530            - Returns one of {ANT_UNCONFIGURED, ANT_CONFIGURED (ANT_CLOSED), ANT_CLOSING, ANT_OPEN, ANT_CLOSED}
    531          
    532          */

   \                                 In section .text, align 2, keep-with-next
    533          AntChannelStatusType AntRadioStatusChannel(AntChannelNumberType eChannel_)
    534          {
   \                     AntRadioStatusChannel: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    535            if(G_asAntChannelConfiguration[eChannel_].AntFlags & _ANT_FLAGS_CHANNEL_CONFIGURED)
   \   00000002   0x....             LDR.N    R0,??DataTable11_3
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2214             MOVS     R2,#+20
   \   00000008   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000000C   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD515             BPL.N    ??AntRadioStatusChannel_0
    536            {
    537              if(G_asAntChannelConfiguration[eChannel_].AntFlags & _ANT_FLAGS_CHANNEL_CLOSE_PENDING)
   \   00000012   0x....             LDR.N    R0,??DataTable11_3
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2214             MOVS     R2,#+20
   \   00000018   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000001C   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000001E   0x0700             LSLS     R0,R0,#+28
   \   00000020   0xD501             BPL.N    ??AntRadioStatusChannel_1
    538              {
    539                return ANT_CLOSING;
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0xE00C             B.N      ??AntRadioStatusChannel_2
    540              }
    541              else if(G_asAntChannelConfiguration[eChannel_].AntFlags & _ANT_FLAGS_CHANNEL_OPEN)
   \                     ??AntRadioStatusChannel_1: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable11_3
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x2214             MOVS     R2,#+20
   \   0000002C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000030   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000032   0x0740             LSLS     R0,R0,#+29
   \   00000034   0xD501             BPL.N    ??AntRadioStatusChannel_3
    542              {
    543                return ANT_OPEN;
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0xE002             B.N      ??AntRadioStatusChannel_2
    544              }
    545              else
    546              {
    547                return ANT_CLOSED;
   \                     ??AntRadioStatusChannel_3: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xE000             B.N      ??AntRadioStatusChannel_2
    548              }
    549            }
    550            else
    551            {
    552              return ANT_UNCONFIGURED;
   \                     ??AntRadioStatusChannel_0: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??AntRadioStatusChannel_2: (+1)
   \   00000040   0x4770             BX       LR               ;; return
    553            }
    554             
    555          } /* end AntRadioStatusChannel () */
    556          
    557          
    558          /***ANT DATA FUNCTIONS***/
    559          
    560          /*-----------------------------------------------------------------------------/
    561          Function: AntQueueBroadcastMessage
    562          
    563          Description:
    564          Adds an ANT broadcast message to the outgoing messages list.  
    565          
    566          Requires:
    567            - eChannel_ is the channel number on which to broadcast
    568            - pu8Data_ is a pointer to the first element of an array of 8 data bytes
    569          
    570          Promises:
    571            - Returns TRUE if the entry is added successfully.
    572          */

   \                                 In section .text, align 2, keep-with-next
    573          bool AntQueueBroadcastMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    574          {
   \                     AntQueueBroadcastMessage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    575            /* Update the dynamic message data */
    576            G_au8AntBroadcastDataMessage[2] = eChannel_;
   \   00000006   0x....             LDR.N    R0,??DataTable11_16
   \   00000008   0x7084             STRB     R4,[R0, #+2]
    577            for(u8 i = 0; i < ANT_DATA_BYTES; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??AntQueueBroadcastMessage_0: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xDA07             BGE.N    ??AntQueueBroadcastMessage_1
    578            {
    579              G_au8AntBroadcastDataMessage[3 + i] = *(pu8Data_ + i);
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x5D41             LDRB     R1,[R0, R5]
   \   00000016   0x....             LDR.N    R2,??DataTable11_16
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x1882             ADDS     R2,R0,R2
   \   0000001C   0x70D1             STRB     R1,[R2, #+3]
    580            }
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0xE7F4             B.N      ??AntQueueBroadcastMessage_0
    581           
    582            G_au8AntBroadcastDataMessage[11] = AntCalculateTxChecksum(G_au8AntBroadcastDataMessage);
   \                     ??AntQueueBroadcastMessage_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable11_16
   \   00000024   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000028   0x....             LDR.N    R1,??DataTable11_16
   \   0000002A   0x72C8             STRB     R0,[R1, #+11]
    583            
    584            return( AntQueueOutgoingMessage(G_au8AntBroadcastDataMessage) );
   \   0000002C   0x....             LDR.N    R0,??DataTable11_16
   \   0000002E   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    585          
    586          } /* end AntQueueBroadcastMessage */
    587          
    588          
    589          /*-----------------------------------------------------------------------------/
    590          Function: AntQueueAcknowledgedMessage
    591          
    592          Description:
    593          Adds an ANT Acknowledged message to the outgoing messages list.  
    594          
    595          Requires:
    596            - eChannel_ is the channel number on which to broadcast
    597            - pu8Data_ is a pointer to the first element of an array of 8 data bytes
    598          
    599          Promises:
    600            - Returns TRUE if the entry is added successfully.
    601          */

   \                                 In section .text, align 2, keep-with-next
    602          bool AntQueueAcknowledgedMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    603          {
   \                     AntQueueAcknowledgedMessage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    604            /* Update the dynamic message data */
    605            G_au8AntAckDataMessage[2] = eChannel_;
   \   00000006   0x....             LDR.N    R0,??DataTable11_17
   \   00000008   0x7084             STRB     R4,[R0, #+2]
    606            for(u8 i = 0; i < ANT_DATA_BYTES; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??AntQueueAcknowledgedMessage_0: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xDA07             BGE.N    ??AntQueueAcknowledgedMessage_1
    607            {
    608              G_au8AntAckDataMessage[3 + i] = *(pu8Data_ + i);
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x5D41             LDRB     R1,[R0, R5]
   \   00000016   0x....             LDR.N    R2,??DataTable11_17
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x1882             ADDS     R2,R0,R2
   \   0000001C   0x70D1             STRB     R1,[R2, #+3]
    609            }
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0xE7F4             B.N      ??AntQueueAcknowledgedMessage_0
    610           
    611            G_au8AntAckDataMessage[11] = AntCalculateTxChecksum(G_au8AntAckDataMessage);
   \                     ??AntQueueAcknowledgedMessage_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable11_17
   \   00000024   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000028   0x....             LDR.N    R1,??DataTable11_17
   \   0000002A   0x72C8             STRB     R0,[R1, #+11]
    612            return( AntQueueOutgoingMessage(G_au8AntAckDataMessage) );
   \   0000002C   0x....             LDR.N    R0,??DataTable11_17
   \   0000002E   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    613           
    614          } /* end AntQueueAcknowledgedMessage */
    615          
    616          
    617          /*-----------------------------------------------------------------------------/
    618          Function: AntReadAppMessageBuffer
    619          
    620          Description:
    621          Checks for any new messages from ANT.  New messages are buffered by ant.c and 
    622          made available to the application on a FIFO basis.  Whenever this function
    623          is called, the global parameters are updated:
    624          G_u32AntApiCurrentMessageTimeStamp
    625          G_eAntApiCurrentMessageClass
    626          G_au8AntApiCurrentMessageBytes
    627          G_sAntApiCurrentMessageExtData
    628          
    629          The application should check G_eAntApiCurrentMessageClass to determine if the message
    630          is ANT_DATA or ANT_TICK and then use G_au8AntApiCurrentMessageBytes and
    631          G_sAntApiCurrentMessageExtData accordingly.
    632          
    633          Requires:
    634            - 
    635          
    636          Promises:
    637            - Returns TRUE if there is new data; 
    638              G_u32AntApiCurrentMessageTimeStamp
    639              G_eAntApiCurrentMessageClass
    640              G_au8AntApiCurrentMessageBytes
    641              G_sAntApiCurrentMessageExtData
    642              are all updated with the oldest data from G_sAntApplicationMsgList and the message
    643              is removed from the buffer.
    644            - Returns FALSE if no new data is present (all variables unchanged)
    645          */

   \                                 In section .text, align 2, keep-with-next
    646          bool AntReadAppMessageBuffer(void)
    647          {
   \                     AntReadAppMessageBuffer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    648            u8 *pu8Parser;
    649            
    650            if(G_sAntApplicationMsgList != NULL)
   \   00000002   0x....             LDR.N    R0,??DataTable11_18
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD03B             BEQ.N    ??AntReadAppMessageBuffer_0
    651            {
    652              /* Grab the single bytes */
    653              G_u32AntApiCurrentMessageTimeStamp = G_sAntApplicationMsgList->u32TimeStamp;
   \   0000000A   0x....             LDR.N    R0,??DataTable11_18
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x....             LDR.N    R1,??DataTable11_19
   \   00000012   0x6008             STR      R0,[R1, #+0]
    654              G_eAntApiCurrentMessageClass = G_sAntApplicationMsgList->eMessageType;
   \   00000014   0x....             LDR.N    R0,??DataTable11_18
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x7900             LDRB     R0,[R0, #+4]
   \   0000001A   0x....             LDR.N    R1,??DataTable11_20
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    655              
    656              /* Copy over all the payload data */
    657              pu8Parser = &(G_sAntApplicationMsgList->au8MessageData[0]);
   \   0000001E   0x....             LDR.N    R0,??DataTable11_18
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF200 0x0006      ADDW     R0,R0,#+6
   \   00000026   0x0004             MOVS     R4,R0
    658              for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??AntReadAppMessageBuffer_1: (+1)
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x2808             CMP      R0,#+8
   \   0000002E   0xDA06             BGE.N    ??AntReadAppMessageBuffer_2
    659              {
    660                G_au8AntApiCurrentMessageBytes[i] = *(pu8Parser + i);
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x5D01             LDRB     R1,[R0, R4]
   \   00000034   0x....             LDR.N    R2,??DataTable11_21
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x5481             STRB     R1,[R0, R2]
    661              }
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0xE7F5             B.N      ??AntReadAppMessageBuffer_1
    662              
    663              /* Copy over the extended data */
    664              G_sAntApiCurrentMessageExtData.u8Channel    = G_sAntApplicationMsgList->sExtendedData.u8Channel;
   \                     ??AntReadAppMessageBuffer_2: (+1)
   \   0000003E   0x....             LDR.N    R0,??DataTable11_18
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x7B80             LDRB     R0,[R0, #+14]
   \   00000044   0x....             LDR.N    R1,??DataTable11_22
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    665              G_sAntApiCurrentMessageExtData.u8Flags      = G_sAntApplicationMsgList->sExtendedData.u8Flags;
   \   00000048   0x....             LDR.N    R0,??DataTable11_18
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x7BC0             LDRB     R0,[R0, #+15]
   \   0000004E   0x....             LDR.N    R1,??DataTable11_22
   \   00000050   0x7048             STRB     R0,[R1, #+1]
    666              G_sAntApiCurrentMessageExtData.u16DeviceID  = G_sAntApplicationMsgList->sExtendedData.u16DeviceID;
   \   00000052   0x....             LDR.N    R0,??DataTable11_18
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x8A00             LDRH     R0,[R0, #+16]
   \   00000058   0x....             LDR.N    R1,??DataTable11_22
   \   0000005A   0x8048             STRH     R0,[R1, #+2]
    667              G_sAntApiCurrentMessageExtData.u8DeviceType = G_sAntApplicationMsgList->sExtendedData.u8DeviceType;
   \   0000005C   0x....             LDR.N    R0,??DataTable11_18
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x7C80             LDRB     R0,[R0, #+18]
   \   00000062   0x....             LDR.N    R1,??DataTable11_22
   \   00000064   0x7108             STRB     R0,[R1, #+4]
    668              G_sAntApiCurrentMessageExtData.u8TransType  = G_sAntApplicationMsgList->sExtendedData.u8TransType;
   \   00000066   0x....             LDR.N    R0,??DataTable11_18
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000006C   0x....             LDR.N    R1,??DataTable11_22
   \   0000006E   0x7148             STRB     R0,[R1, #+5]
    669              G_sAntApiCurrentMessageExtData.s8RSSI       = G_sAntApplicationMsgList->sExtendedData.s8RSSI;
   \   00000070   0x....             LDR.N    R0,??DataTable11_18
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x7D00             LDRB     R0,[R0, #+20]
   \   00000076   0x....             LDR.N    R1,??DataTable11_22
   \   00000078   0x7188             STRB     R0,[R1, #+6]
    670              
    671              /* Done, so message can be removed from the buffer */
    672              AntDeQueueApplicationMessage();    
   \   0000007A   0x.... 0x....      BL       AntDeQueueApplicationMessage
    673              return TRUE;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xE000             B.N      ??AntReadAppMessageBuffer_3
    674            }
    675            
    676            /* Otherwise return FALSE and do not touch the current data array */
    677            return FALSE;
   \                     ??AntReadAppMessageBuffer_0: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \                     ??AntReadAppMessageBuffer_3: (+1)
   \   00000084   0xBD10             POP      {R4,PC}          ;; return
    678            
    679          } /* end AntReadAppMessageBuffer() */
    680          
    681          
    682          /*--------------------------------------------------------------------------------------------------------------------*/
    683          /* Protected functions                                                                                                */
    684          /*--------------------------------------------------------------------------------------------------------------------*/
    685          
    686          /*-----------------------------------------------------------------------------/
    687          Function: AntApiInitialize
    688          
    689          Description:
    690          Configures the Ant API task.
    691          
    692          Requires:
    693            - 
    694          
    695          Promises:
    696            - 
    697          */

   \                                 In section .text, align 2, keep-with-next
    698          void AntApiInitialize(void)
    699          {
   \                     AntApiInitialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    700            /* If good initialization, set state to Idle */
    701            if( 1 )
    702            {
    703              DebugPrintf("ANT API ready\n\r");
   \   00000002   0x....             LDR.N    R0,??DataTable11_23
   \   00000004   0x.... 0x....      BL       DebugPrintf
    704              AntApi_StateMachine = AntApiSM_Idle;
   \   00000008   0x.... 0x....      ADR.W    R0,AntApiSM_Idle
   \   0000000C   0x....             LDR.N    R1,??DataTable11_11
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    705            }
    706            else
    707            {
    708              /* The task isn't properly initialized, so shut it down and don't run */
    709              AntApi_StateMachine = AntApiSM_FailedInit;
    710            }
    711          
    712          } /* end AntApiInitialize() */
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    713          
    714          
    715          /*----------------------------------------------------------------------------------------------------------------------
    716          Function UserAppRunActiveState()
    717          
    718          Description:
    719          Selects and runs one iteration of the current state in the state machine.
    720          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    721          may take 1ms / n to execute.
    722          
    723          Requires:
    724            - State machine function pointer points at current state
    725          
    726          Promises:
    727            - Calls the function to pointed by the state machine function pointer
    728          */

   \                                 In section .text, align 2, keep-with-next
    729          void AntApiRunActiveState(void)
    730          {
   \                     AntApiRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    731            AntApi_StateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable11_11
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    732          
    733          } /* end AntApiRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    734          
    735          
    736          /**********************************************************************************************************************
    737          State Machine Function Definitions
    738          **********************************************************************************************************************/
    739          
    740          /*-------------------------------------------------------------------------------------------------------------------*/
    741          /* Wait for a message to be queued */

   \                                 In section .text, align 4, keep-with-next
    742          static void AntApiSM_Idle(void)
    743          {
    744            /* Monitor requests to send generic ANT messages */
    745            
    746          } /* end AntApiSM_Idle() */
   \                     AntApiSM_Idle: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    747               
    748          
    749          /*-------------------------------------------------------------------------------------------------------------------*/
    750          /* Send all configuration messages to ANT to fully assign the channel.
    751          The selected channel has already been verified unconfigured, and all required setup
    752          messages are ready to go.  */

   \                                 In section .text, align 4, keep-with-next
    753          static void  AntApiSM_AssignChannel(void)          
    754          {
   \                     AntApiSM_AssignChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    755            static u8 u8CurrentMessageToSend = 0;
    756            static u8 u8CurrentMesssageId = 0;
    757            static bool bMessageInProgress = FALSE;
    758            
    759            /* Queue the next message if it's time */
    760            if(bMessageInProgress == FALSE)
   \   00000002   0x....             LDR.N    R0,??DataTable11_24
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD111             BNE.N    ??AntApiSM_AssignChannel_0
    761            {
    762              u8CurrentMesssageId = *(AntApi_apu8AntAssignChannel[u8CurrentMessageToSend] + BUFFER_INDEX_MESG_ID); 
   \   0000000A   0x....             LDR.N    R0,??DataTable11_25
   \   0000000C   0x....             LDR.N    R1,??DataTable11_26
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000014   0x7840             LDRB     R0,[R0, #+1]
   \   00000016   0x....             LDR.N    R1,??DataTable11_27
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    763              AntQueueOutgoingMessage(AntApi_apu8AntAssignChannel[u8CurrentMessageToSend]);
   \   0000001A   0x....             LDR.N    R0,??DataTable11_25
   \   0000001C   0x....             LDR.N    R1,??DataTable11_26
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000024   0x.... 0x....      BL       AntQueueOutgoingMessage
    764              bMessageInProgress = TRUE;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x....             LDR.N    R1,??DataTable11_24
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    765            }
    766            
    767            /* Check message status */
    768            if( u8CurrentMesssageId == G_stMessageResponse.u8MessageNumber )
   \                     ??AntApiSM_AssignChannel_0: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable11_27
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x....             LDR.N    R1,??DataTable11_28
   \   00000034   0x7849             LDRB     R1,[R1, #+1]
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD139             BNE.N    ??AntApiSM_AssignChannel_1
    769            { 
    770              if(G_stMessageResponse.u8ResponseCode == RESPONSE_NO_ERROR)
   \   0000003A   0x....             LDR.N    R0,??DataTable11_28
   \   0000003C   0x7880             LDRB     R0,[R0, #+2]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD129             BNE.N    ??AntApiSM_AssignChannel_2
    771              {
    772                /* Increment message pointer and check if complete */
    773                u8CurrentMessageToSend++;
   \   00000042   0x....             LDR.N    R0,??DataTable11_26
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x....             LDR.N    R1,??DataTable11_26
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    774                if(u8CurrentMessageToSend == ANT_ASSIGN_MESSAGES)
   \   0000004C   0x....             LDR.N    R0,??DataTable11_26
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x2807             CMP      R0,#+7
   \   00000052   0xD129             BNE.N    ??AntApiSM_AssignChannel_3
    775                {
    776                  /* Print OK message and update the channel flags */
    777                  G_au8AntMessageAssign[12] = G_stMessageResponse.u8Channel;
   \   00000054   0x....             LDR.N    R0,??DataTable11_28
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x....             LDR.N    R1,??DataTable11_29
   \   0000005A   0x7308             STRB     R0,[R1, #+12]
    778                  DebugPrintf(G_au8AntMessageAssign);
   \   0000005C   0x....             LDR.N    R0,??DataTable11_29
   \   0000005E   0x.... 0x....      BL       DebugPrintf
    779                  DebugPrintf(G_au8AntMessageOk);
   \   00000062   0x....             LDR.N    R0,??DataTable11_30
   \   00000064   0x.... 0x....      BL       DebugPrintf
    780                  G_asAntChannelConfiguration[G_stMessageResponse.u8Channel].AntFlags |= _ANT_FLAGS_CHANNEL_CONFIGURED;
   \   00000068   0x....             LDR.N    R0,??DataTable11_3
   \   0000006A   0x....             LDR.N    R1,??DataTable11_28
   \   0000006C   0x7809             LDRB     R1,[R1, #+0]
   \   0000006E   0x2214             MOVS     R2,#+20
   \   00000070   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000074   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000076   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000007A   0x....             LDR.N    R1,??DataTable11_3
   \   0000007C   0x....             LDR.N    R2,??DataTable11_28
   \   0000007E   0x7812             LDRB     R2,[R2, #+0]
   \   00000080   0x2314             MOVS     R3,#+20
   \   00000082   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000086   0x74C8             STRB     R0,[R1, #+19]
    781          
    782                  /* Clean up and exit this state */
    783                  u8CurrentMessageToSend = 0;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x....             LDR.N    R1,??DataTable11_26
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
    784                  AntApi_StateMachine = AntApiSM_Idle;
   \   0000008E   0x....             LDR.N    R0,??DataTable11_31
   \   00000090   0x....             LDR.N    R1,??DataTable11_11
   \   00000092   0x6008             STR      R0,[R1, #+0]
   \   00000094   0xE008             B.N      ??AntApiSM_AssignChannel_3
    785                }
    786              } 
    787              else
    788              {
    789                /* Report the error and return.  Channel flags will remain clear for application to check. */
    790                DebugPrintf(G_au8AntMessageAssign);
   \                     ??AntApiSM_AssignChannel_2: (+1)
   \   00000096   0x....             LDR.N    R0,??DataTable11_29
   \   00000098   0x.... 0x....      BL       DebugPrintf
    791                DebugPrintf(G_au8AntMessageFail);
   \   0000009C   0x....             LDR.N    R0,??DataTable11_32
   \   0000009E   0x.... 0x....      BL       DebugPrintf
    792                AntApi_StateMachine = AntApiSM_Idle;
   \   000000A2   0x....             LDR.N    R0,??DataTable11_31
   \   000000A4   0x....             LDR.N    R1,??DataTable11_11
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    793              }
    794          
    795              /* In either case, clean up the following: */
    796              bMessageInProgress = FALSE;
   \                     ??AntApiSM_AssignChannel_3: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x....             LDR.N    R1,??DataTable11_24
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
    797          
    798            } /* end if( u8CurrentMesssageId == G_stMessageResponse.u8MessageNumber ) */
    799            
    800            /* Check for timeout */
    801            if(IsTimeUp(&AntApi_u32Timeout, ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntApiSM_AssignChannel_1: (+1)
   \   000000AE   0xF242 0x7110      MOVW     R1,#+10000
   \   000000B2   0x....             LDR.N    R0,??DataTable11_10
   \   000000B4   0x.... 0x....      BL       IsTimeUp
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD008             BEQ.N    ??AntApiSM_AssignChannel_4
    802            {
    803              /* Report the error and return.  Channel flags will remain clear for application to check. */
    804              DebugPrintf(G_au8AntMessageAssign);
   \   000000BC   0x....             LDR.N    R0,??DataTable11_29
   \   000000BE   0x.... 0x....      BL       DebugPrintf
    805              DebugPrintf(G_au8AntMessageFail);
   \   000000C2   0x....             LDR.N    R0,??DataTable11_32
   \   000000C4   0x.... 0x....      BL       DebugPrintf
    806              AntApi_StateMachine = AntApiSM_Idle;
   \   000000C8   0x....             LDR.N    R0,??DataTable11_31
   \   000000CA   0x....             LDR.N    R1,??DataTable11_11
   \   000000CC   0x6008             STR      R0,[R1, #+0]
    807            }
    808            
    809          } /* end AntApiSM_AssignChannel() */
   \                     ??AntApiSM_AssignChannel_4: (+1)
   \   000000CE   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 1
   \                     ??u8CurrentMessageToSend:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??u8CurrentMesssageId:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??bMessageInProgress:
   \   00000000                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     G_au8AntLibConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     G_au8AntSetNetworkKey

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     G_asAntChannelConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     G_au8AntAssignChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     G_au8AntSetChannelID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     G_au8AntSetChannelPeriod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     G_au8AntSetChannelRFFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     G_au8AntSetChannelPower

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     AntApi_u32Timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x........         DC32     AntApi_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   0x........         DC32     G_au8AntBroadcastDataMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \   00000000   0x........         DC32     G_au8AntAckDataMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \   00000000   0x........         DC32     G_sAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \   00000000   0x........         DC32     G_u32AntApiCurrentMessageTimeStamp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \   00000000   0x........         DC32     G_eAntApiCurrentMessageClass

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \   00000000   0x........         DC32     G_au8AntApiCurrentMessageBytes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \   00000000   0x........         DC32     G_sAntApiCurrentMessageExtData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_23:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_24:
   \   00000000   0x........         DC32     ??bMessageInProgress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_25:
   \   00000000   0x........         DC32     AntApi_apu8AntAssignChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_26:
   \   00000000   0x........         DC32     ??u8CurrentMessageToSend

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_27:
   \   00000000   0x........         DC32     ??u8CurrentMesssageId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_28:
   \   00000000   0x........         DC32     G_stMessageResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_29:
   \   00000000   0x........         DC32     G_au8AntMessageAssign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_30:
   \   00000000   0x........         DC32     G_au8AntMessageOk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_31:
   \   00000000   0x........         DC32     AntApiSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_32:
   \   00000000   0x........         DC32     G_au8AntMessageFail

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x41 0x6E          DC8 41H, 6EH, 74H, 41H, 73H, 73H, 69H, 67H
   \              0x74 0x41    
   \              0x73 0x73    
   \              0x69 0x67    
   \   00000008   0x6E 0x43          DC8 6EH, 43H, 68H, 61H, 6EH, 6EH, 65H, 6CH
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \   00000010   0x20 0x65          DC8 20H, 65H, 72H, 72H, 6FH, 72H, 3AH, 20H
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \   00000018   0x63 0x68          DC8 63H, 68H, 61H, 6EH, 6EH, 65H, 6CH, 20H
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \   00000020   0x69 0x73          DC8 69H, 73H, 20H, 6EH, 6FH, 74H, 20H, 75H
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x75    
   \   00000028   0x6E 0x63          DC8 6EH, 63H, 6FH, 6EH, 66H, 69H, 67H, 75H
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x75    
   \   00000030   0x72 0x65          DC8 72H, 65H, 64H, 0AH, 0DH, 0
   \              0x64 0x0A    
   \              0x0D 0x00    
   \   00000036   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x01 0x41          DC8 1, 65, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x01 0x4B          DC8 1, 75, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x01 0x5B          DC8 1, 91, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x01 0x4C          DC8 1, 76, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x41 0x4E          DC8 "ANT API ready\012\015"
   \              0x54 0x20    
   \              0x41 0x50    
   \              0x49 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
    810          
    811          
    812          #if 0
    813          /*-------------------------------------------------------------------------------------------------------------------*/
    814          /* Handle an error */
    815          static void  AntApiSM_Error(void)          
    816          {
    817            
    818          } /* end AntApiSM_Error() */
    819          #endif
    820          
    821          
    822          /*-------------------------------------------------------------------------------------------------------------------*/
    823          /* State to sit in if init failed */
    824          static void  AntApiSM_FailedInit(void)          
    825          {
    826              
    827          } /* end AntApiSM_FailedInit() */
    828          
    829          
    830          /*--------------------------------------------------------------------------------------------------------------------*/
    831          /* End of File                                                                                                        */
    832          /*--------------------------------------------------------------------------------------------------------------------*/
    833          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AntApiInitialize
         8   -> DebugPrintf
       8   AntApiRunActiveState
         8   -- Indirect call
       8   AntApiSM_AssignChannel
         8   -> AntQueueOutgoingMessage
         8   -> DebugPrintf
         8   -> IsTimeUp
       0   AntApiSM_Idle
       8   AntAssignChannel
         8   -> AntCalculateTxChecksum
         8   -> AntRadioStatusChannel
         8   -> DebugPrintf
      16   AntCloseChannelNumber
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
      16   AntOpenChannelNumber
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
       8   AntOpenScanningChannel
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage
      16   AntQueueAcknowledgedMessage
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
      16   AntQueueBroadcastMessage
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
       0   AntRadioStatusChannel
       8   AntReadAppMessageBuffer
         8   -> AntDeQueueApplicationMessage
      16   AntUnassignChannelNumber
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_23
       4  ??DataTable11_24
       4  ??DataTable11_25
       4  ??DataTable11_26
       4  ??DataTable11_27
       4  ??DataTable11_28
       4  ??DataTable11_29
       4  ??DataTable11_3
       4  ??DataTable11_30
       4  ??DataTable11_31
       4  ??DataTable11_32
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      56  ?_0
       4  ?_1
       4  ?_2
       4  ?_3
       4  ?_4
      16  ?_5
      18  AntApiInitialize
      10  AntApiRunActiveState
     208  AntApiSM_AssignChannel
       2  AntApiSM_Idle
       4  AntApi_StateMachine
      28  AntApi_apu8AntAssignChannel
       4  AntApi_u32Timeout
     490  AntAssignChannel
      64  AntCloseChannelNumber
      70  AntOpenChannelNumber
      40  AntOpenScanningChannel
      52  AntQueueAcknowledgedMessage
      52  AntQueueBroadcastMessage
      66  AntRadioStatusChannel
     134  AntReadAppMessageBuffer
      66  AntUnassignChannelNumber
       8  G_au8AntApiCurrentMessageBytes
       1  G_eAntApiCurrentMessageClass
       8  G_sAntApiCurrentMessageExtData
       4  G_u32AntApiCurrentMessageTimeStamp
       4  G_u32AntApiFlags
       1  bMessageInProgress
       1  u8CurrentMessageToSend
       1  u8CurrentMesssageId

 
    36 bytes in section .bss
    28 bytes in section .data
    88 bytes in section .rodata
 1 404 bytes in section .text
 
 1 404 bytes of CODE  memory
    88 bytes of CONST memory
    64 bytes of DATA  memory

Errors: none
Warnings: 1
